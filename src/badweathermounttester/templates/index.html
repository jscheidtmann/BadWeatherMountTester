<!DOCTYPE html>
<html lang="{{ get_locale() }}">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ _('Bad Weather Mount Tester') }}</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, sans-serif;
            background-color: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            padding: 10px 15px;
            font-size: 17px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            color: #00d4ff;
            font-size: 1.4em;
        }

        .card {
            background-color: #16213e;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 10px;
        }

        .card h2 {
            margin-bottom: 8px;
            color: #00d4ff;
            font-size: 1em;
        }

        .form-group {
            margin-bottom: 8px;
        }

        .form-group:last-child {
            margin-bottom: 0;
        }

        .form-group label {
            display: block;
            margin-bottom: 2px;
            color: #aaa;
            font-size: 0.85em;
        }

        .form-group input {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #333;
            border-radius: 4px;
            background-color: #0f0f23;
            color: #eee;
            font-size: 17px;
        }

        .form-group input:focus {
            outline: none;
            border-color: #00d4ff;
        }

        .btn {
            display: inline-block;
            padding: 8px 16px;
            background-color: #00d4ff;
            color: #000;
            border: none;
            border-radius: 4px;
            font-size: 17px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .btn:hover {
            background-color: #00a8cc;
        }

        .btn:disabled {
            background-color: #555;
            cursor: not-allowed;
        }

        .btn-secondary {
            background-color: #444;
            color: #eee;
        }

        .btn-secondary:hover {
            background-color: #555;
        }

        .status {
            text-align: center;
            padding: 6px;
            border-radius: 4px;
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        .status.connected {
            background-color: #1b4332;
            color: #95d5b2;
        }

        .step-indicator {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .step {
            flex: 1;
            text-align: center;
            padding: 6px 4px;
            background-color: #0f0f23;
            margin: 0 3px;
            border-radius: 4px;
            color: #666;
            font-size: 0.85em;
        }

        .step.active {
            background-color: #00d4ff;
            color: #000;
        }

        .step.completed {
            background-color: #1b4332;
            color: #95d5b2;
        }

        .actions {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
        }

        .config-row {
            display: flex;
            gap: 12px;
            margin-bottom: 10px;
        }

        .config-row .card {
            flex: 1;
            margin-bottom: 0;
        }

        .calc-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px 16px;
        }

        .calc-grid p {
            margin: 0;
            font-size: 0.9em;
        }

        .screen-calc {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #333;
        }

        .screen-calc p {
            margin: 0 0 2px 0;
            font-size: 0.85em;
            color: #aaa;
        }

        .screen-calc p:last-child {
            margin-bottom: 0;
        }

        .instructions-card {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: #000;
            border: 2px solid #fbbf24;
            padding: 10px 14px;
        }

        .instructions-card h2 {
            color: #000;
            font-size: 0.95em;
            margin-bottom: 4px;
        }

        .instructions-card p {
            margin: 0 0 6px 0;
            font-size: 0.9em;
            font-weight: 500;
        }

        .instructions-card ol {
            margin: 0 0 6px 0;
            padding-left: 20px;
            font-size: 0.9em;
            font-weight: 500;
        }

        .instructions-card li {
            margin-bottom: 2px;
        }

        .instructions-card li:last-child {
            margin-bottom: 0;
        }

        .instructions-card > *:last-child {
            margin-bottom: 0;
        }

        .step-content {
            display: none;
        }

        .step-content.active {
            display: block;
        }

        .calibration-canvas-container {
            background-color: #000;
            border: 2px solid #333;
            border-radius: 4px;
            margin: 10px 0;
            cursor: crosshair;
            position: relative;
        }

        #calibration-canvas {
            display: block;
            width: 100%;
            height: auto;
        }

        .calibration-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 8px;
        }

        .calibration-info span {
            font-size: 0.9em;
            color: #aaa;
        }

        .calibration-buttons {
            display: flex;
            gap: 8px;
        }

        .btn-small {
            padding: 4px 10px;
            font-size: 14px;
        }

        .btn-danger {
            background-color: #dc3545;
            color: #fff;
        }

        .btn-danger:hover {
            background-color: #c82333;
        }

        .polynomial-display {
            text-align: center;
            padding: 8px 12px;
            margin-top: 10px;
            background-color: #1a1a2e;
            border: 1px solid #333;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9em;
            color: #ff6b6b;
        }

        @media (max-width: 600px) {
            .config-row {
                flex-direction: column;
            }
            .config-row .card {
                margin-bottom: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>{{ _('Bad Weather Mount Tester') }}</h1>

        <div class="status connected">
            {{ _('Connected to Simulator') }}
        </div>

        <div class="step-indicator">
            <div class="step active" id="step-1">1. {{ _('Configure') }}</div>
            <div class="step" id="step-2">2. {{ _('Align') }}</div>
            <div class="step" id="step-3">3. {{ _('Calibrate') }}</div>
            <div class="step" id="step-4">4. {{ _('Measure') }}</div>
        </div>

        <!-- Step 1: Configure -->
        <div class="step-content active" id="step-1-content">
            <div class="config-row">
                <div class="card" id="config-card">
                    <h2>{{ _('Mount Configuration') }}</h2>
                    <div class="form-group">
                        <label for="latitude">{{ _('Latitude (degrees)') }}</label>
                        <input type="number" id="latitude" step="0.1" value="0">
                    </div>
                    <div class="form-group">
                        <label for="focal-length">{{ _('Guide Scope Focal Length (mm)') }}</label>
                        <input type="number" id="focal-length" step="1" value="200">
                    </div>
                    <div class="form-group">
                        <label for="distance">{{ _('Distance to Screen (m)') }}</label>
                        <input type="number" id="distance" step="0.1" value="5">
                    </div>
                    <div class="form-group">
                        <label for="period">{{ _('Mount Main Period (seconds)') }}</label>
                        <input type="number" id="period" step="1" value="480">
                    </div>
                </div>

                <div class="card" id="camera-card">
                    <h2>{{ _('Guiding Camera') }}</h2>
                    <div class="form-group">
                        <label for="pixel-size">{{ _('Pixel Size (micrometer)') }}</label>
                        <input type="number" id="pixel-size" step="0.01" value="3.75">
                    </div>
                    <div class="form-group">
                        <label for="camera-width">{{ _('Width (pixels)') }}</label>
                        <input type="number" id="camera-width" step="1" value="1280">
                    </div>
                    <div class="form-group">
                        <label for="camera-height">{{ _('Height (pixels)') }}</label>
                        <input type="number" id="camera-height" step="1" value="960">
                    </div>
                    <div class="screen-calc">
                        <p>{{ _('Resolution:') }}</p>
                        <p><strong id="camera-resolution-arcsec">--</strong> arcsec/px</p>
                    </div>
                </div>

                <div class="card" id="screen-card">
                    <h2>{{ _('Screen') }}</h2>
                    <div class="form-group">
                        <label for="screen-width-mm">{{ _('Screen Width (mm)') }}</label>
                        <input type="number" id="screen-width-mm" step="1" value="527">
                    </div>
                    <div class="screen-calc">
                        <p>{{ _('Pixel Pitch:') }}</p>
                        <p><strong id="pixel-pitch-mm">--</strong> mm/px</p>
                        <p><strong id="pixel-pitch-arcsec">--</strong> arcsec/px</p>
                    </div>
                </div>
            </div>

            <div class="card" id="info-card">
                <h2>{{ _('Calculated Values') }}</h2>
                <div class="calc-grid">
                    <p>{{ _('Effective FL for PHD2:') }} <strong id="effective-focal">--</strong> mm</p>
                    <p>{{ _('Measurement duration:') }} ~<strong id="duration">--</strong> {{ _('minutes') }}</p>
                    <p>{{ _('Recommended Binning:') }} <strong id="binning">--</strong>x</p>
                    <p>{{ _('Area on Simulator:') }} <strong id="area-width">--</strong> x <strong id="area-height">--</strong> mm</p>
                </div>
            </div>

            <div class="card instructions-card">
                <h2>{{ _('Instructions') }}</h2>
                <p>{{ _('Fill in the values above, then set up PHD2 as follows:') }}</p>
                <ol>
                    <li>{{ _('Create a new guiding profile in PHD2 with the Effective FL and Binning values as listed above.') }}</li>
                    <li>{{ _('Disable multi-star guiding (we use one simulated star).') }}</li>
                    <li>{{ _('Start looping in PHD2.') }}</li>
                    <li>{{ _('From the Tools menu, enable the cross in the camera display.') }}</li>
                    <li>{{ _('Point the mount at the simulator display, focus and locate the cross, by following the arrows') }}</li>
                    <li>{{ _('While on the way orient the simulator display such (grid), that you\'re roughly in focus all over the simulator display') }}</li>
                </ol>
                <p>{{ _('Then press "Next" to start aligning the mount.') }}</p>
            </div>
        </div>

        <!-- Step 2: Align -->
        <div class="step-content" id="step-2-content">
            <div class="card instructions-card">
                <h2>{{ _('Instructions') }}</h2>
                <p>{{ _('Rotate the mount in Azimuth, so that when going from left-to-right, the red line will be visible when rotating the mount only in RA.') }}</p>
                <p>{{ _('Press "Next" when aligned, or "Back" to return to configuration.') }}</p>
            </div>
        </div>

        <!-- Step 3: Calibrate -->
        <div class="step-content" id="step-3-content">
            <div class="card instructions-card">
                <h2>{{ _('Instructions') }}</h2>
                <ol>
                    <li>{{ _('Look at PHD2 to see where the white crosshair appears on the simulator screen.') }}</li>
                    <li>{{ _('Click on the preview below at that location to record a point.') }}</li>
                    <li>{{ _('Fine-tune the point position using keyboard: Arrow keys or S/E/D/F (left/up/down/right).') }}</li>
                    <li>{{ _('Move the mount in RA a few pixels, then repeat steps 1-3.') }}</li>
                    <li>{{ _('Continue until you have traced across the entire screen.') }}</li>
                </ol>
                <p><strong>{{ _('Keyboard:') }}</strong> {{ _('Arrows/S/E/D/F = move 1px | Q/PgUp = previous point | A/PgDn = next point') }}</p>
                <p>{{ _('The selected point is shown in yellow. New points are auto-selected.') }}</p>
            </div>

            <div class="card">
                <h2>{{ _('Calibration Preview') }}</h2>
                <div class="calibration-canvas-container" id="calibration-canvas-container">
                    <canvas id="calibration-canvas"></canvas>
                </div>
                <div class="calibration-info">
                    <span>{{ _('Points collected:') }} <strong id="point-count">0</strong></span>
                    <div class="calibration-buttons">
                        <button class="btn btn-danger btn-small" id="btn-reset-calibration">{{ _('Reset') }}</button>
                        <button class="btn btn-secondary btn-small" id="btn-delete-last">{{ _('Delete Last') }}</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Step 4: Measure -->
        <div class="step-content" id="step-4-content">
            <div class="card instructions-card">
                <h2>{{ _('Instructions') }}</h2>
                <p>{{ _('Measurement step - coming soon.') }}</p>
            </div>
        </div>

        <div class="polynomial-display" id="polynomial-display" style="display: none;">
            <span id="polynomial-formula"></span>
        </div>

        <div class="actions">
            <button class="btn btn-secondary" id="btn-back" disabled>{{ _('Back') }}</button>
            <button class="btn" id="btn-next">{{ _('Next') }}</button>
        </div>
    </div>

    <script>
        // State management
        let currentStep = 1;
        let mountConfig = {
            latitude: 0,
            focal_length_mm: 200,
            distance_to_screen_m: 5,
            main_period_seconds: 480
        };
        let cameraConfig = {
            pixel_size_um: 3.75,
            width_px: 1280,
            height_px: 960
        };
        let displayConfig = {
            screen_width_mm: 527,
            screen_width: 1920,
            screen_height: 1080
        };

        // Debounce timers for each field
        const debounceTimers = {};
        const DEBOUNCE_DELAY = 300; // milliseconds

        // DOM elements - Mount
        const latitudeInput = document.getElementById('latitude');
        const focalLengthInput = document.getElementById('focal-length');
        const distanceInput = document.getElementById('distance');
        const periodInput = document.getElementById('period');

        // DOM elements - Camera
        const pixelSizeInput = document.getElementById('pixel-size');
        const cameraWidthInput = document.getElementById('camera-width');
        const cameraHeightInput = document.getElementById('camera-height');

        // DOM elements - Camera calculated
        const cameraResolutionArcsecSpan = document.getElementById('camera-resolution-arcsec');

        // DOM elements - Screen
        const screenWidthMmInput = document.getElementById('screen-width-mm');
        const pixelPitchMmSpan = document.getElementById('pixel-pitch-mm');
        const pixelPitchArcsecSpan = document.getElementById('pixel-pitch-arcsec');

        // DOM elements - Calculated values
        const effectiveFocalSpan = document.getElementById('effective-focal');
        const durationSpan = document.getElementById('duration');
        const binningSpan = document.getElementById('binning');
        const areaWidthSpan = document.getElementById('area-width');
        const areaHeightSpan = document.getElementById('area-height');
        const btnBack = document.getElementById('btn-back');
        const btnNext = document.getElementById('btn-next');

        // Field mapping: input element id -> {section, apiField}
        const fieldMapping = {
            'latitude': { section: 'mount', apiField: 'latitude' },
            'focal-length': { section: 'mount', apiField: 'focal_length_mm' },
            'distance': { section: 'mount', apiField: 'distance_to_screen_m' },
            'period': { section: 'mount', apiField: 'main_period_seconds' },
            'pixel-size': { section: 'camera', apiField: 'pixel_size_um' },
            'camera-width': { section: 'camera', apiField: 'width_px' },
            'camera-height': { section: 'camera', apiField: 'height_px' },
            'screen-width-mm': { section: 'display', apiField: 'screen_width_mm' }
        };

        // Load initial config from server
        async function loadConfig() {
            try {
                const response = await fetch('/api/config');
                const data = await response.json();
                mountConfig = data.mount;
                cameraConfig = data.camera;
                displayConfig = {
                    ...displayConfig,
                    ...data.display
                };
                updateInputs();
                updateCalculations();
            } catch (error) {
                console.error('Failed to load config:', error);
            }
        }

        function updateInputs() {
            latitudeInput.value = mountConfig.latitude;
            focalLengthInput.value = mountConfig.focal_length_mm;
            distanceInput.value = mountConfig.distance_to_screen_m;
            periodInput.value = mountConfig.main_period_seconds;

            pixelSizeInput.value = cameraConfig.pixel_size_um;
            cameraWidthInput.value = cameraConfig.width_px;
            cameraHeightInput.value = cameraConfig.height_px;

            screenWidthMmInput.value = displayConfig.screen_width_mm;
        }

        function updateCalculations() {
            // Calculate effective focal length
            const fl = mountConfig.focal_length_mm / 1000; // Convert to meters
            const dist = mountConfig.distance_to_screen_m;
            let effectiveFL = 0;

            if (dist > fl && dist > 0 && mountConfig.focal_length_mm > 0) {
                effectiveFL = (mountConfig.focal_length_mm * dist) / (dist - fl);
                effectiveFocalSpan.textContent = effectiveFL.toFixed(1);
            } else {
                effectiveFocalSpan.textContent = '--';
            }

            // Camera resolution in arcsec/pixel
            if (effectiveFL > 0 && cameraConfig.pixel_size_um > 0) {
                const cameraResolutionArcsec = 206.265 * cameraConfig.pixel_size_um / effectiveFL;
                cameraResolutionArcsecSpan.textContent = cameraResolutionArcsec.toFixed(2);
            } else {
                cameraResolutionArcsecSpan.textContent = '--';
            }

            // Screen pixel pitch calculations
            const screenWidthMm = displayConfig.screen_width_mm;
            const screenWidthPx = displayConfig.screen_width;

            if (screenWidthMm > 0 && screenWidthPx > 0) {
                // Pixel pitch in mm/pixel
                const pixelPitchMm = screenWidthMm / screenWidthPx;
                pixelPitchMmSpan.textContent = pixelPitchMm.toFixed(3);

                // Pixel pitch in arcsec/pixel (angular size as seen from mount)
                if (dist > 0) {
                    // angle = size / distance, convert to arcsec (* 206265)
                    const pixelPitchArcsec = (pixelPitchMm / (dist * 1000)) * 206265;
                    pixelPitchArcsecSpan.textContent = pixelPitchArcsec.toFixed(2);
                } else {
                    pixelPitchArcsecSpan.textContent = '--';
                }
            } else {
                pixelPitchMmSpan.textContent = '--';
                pixelPitchArcsecSpan.textContent = '--';
            }

            // Duration is based on sidereal rate and pixel pitch
            if (screenWidthMm > 0 && screenWidthPx > 0 && dist > 0) {
                const pixelPitchMm = screenWidthMm / screenWidthPx;
                const pixelPitchArcsec = (pixelPitchMm / (dist * 1000)) * 206265;
                const durationMinutes = pixelPitchArcsec * screenWidthPx / 15.0 / 60.0; // Assuming 15 arcsec/sec sidereal rate and convert to minutes;
                durationSpan.textContent = durationMinutes.toFixed(1);
            } else {
                durationSpan.textContent = '--';
            }

            // Camera and display dependent calculations
            if (effectiveFL > 0 && cameraConfig.pixel_size_um > 0 && dist > 0 && screenWidthPx > 0) {
                // Binning: 10 camera pixel should match ~1 simulator pixel
                // Camera pixel projected onto screen = (pixel_size_um * dist) / effective_fl mm
                // Screen pixel size = screen_width_mm / screen_width_px mm
                const cameraPixelOnScreen = (cameraConfig.pixel_size_um * dist) / effectiveFL;
                const screenPixelSize = screenWidthMm / screenWidthPx;
                const recommendedBinning = Math.max(1, Math.round(screenPixelSize / 10.0 / cameraPixelOnScreen));
                binningSpan.textContent = recommendedBinning;

                // Area on simulator (physical size in mm)
                const sensorWidthMm = (cameraConfig.width_px * cameraConfig.pixel_size_um) / 1000;
                const sensorHeightMm = (cameraConfig.height_px * cameraConfig.pixel_size_um) / 1000;
                const areaWidthMm = (sensorWidthMm * dist * 1000) / effectiveFL;
                const areaHeightMm = (sensorHeightMm * dist * 1000) / effectiveFL;
                areaWidthSpan.textContent = areaWidthMm.toFixed(1);
                areaHeightSpan.textContent = areaHeightMm.toFixed(1);
            } else {
                binningSpan.textContent = '--';
                areaWidthSpan.textContent = '--';
                areaHeightSpan.textContent = '--';
            }
        }

        // Update calculated values from server response
        function applyCalculatedValues(calculated) {
            if (calculated.effective_focal_length !== undefined) {
                effectiveFocalSpan.textContent = calculated.effective_focal_length || '--';
            }
            if (calculated.duration_minutes !== undefined) {
                durationSpan.textContent = calculated.duration_minutes || '--';
            }
            if (calculated.camera_resolution_arcsec !== undefined) {
                cameraResolutionArcsecSpan.textContent = calculated.camera_resolution_arcsec || '--';
            }
            if (calculated.recommended_binning !== undefined) {
                binningSpan.textContent = calculated.recommended_binning || '--';
            }
            if (calculated.area_width_mm !== undefined && calculated.area_height_mm !== undefined) {
                areaWidthSpan.textContent = calculated.area_width_mm || '--';
                areaHeightSpan.textContent = calculated.area_height_mm || '--';
            }
            if (calculated.pixel_pitch_mm !== undefined) {
                pixelPitchMmSpan.textContent = calculated.pixel_pitch_mm || '--';
            }
            if (calculated.pixel_pitch_arcsec !== undefined) {
                pixelPitchArcsecSpan.textContent = calculated.pixel_pitch_arcsec || '--';
            }
        }

        // Update local config from input values and recalculate
        function updateLocalConfig() {
            const lat = parseFloat(latitudeInput.value);
            const fl = parseFloat(focalLengthInput.value);
            const dist = parseFloat(distanceInput.value);
            const period = parseFloat(periodInput.value);

            if (!isNaN(lat)) mountConfig.latitude = lat;
            if (!isNaN(fl) && fl > 0) mountConfig.focal_length_mm = fl;
            if (!isNaN(dist) && dist > 0) mountConfig.distance_to_screen_m = dist;
            if (!isNaN(period) && period > 0) mountConfig.main_period_seconds = period;

            const pixelSize = parseFloat(pixelSizeInput.value);
            const camWidth = parseInt(cameraWidthInput.value);
            const camHeight = parseInt(cameraHeightInput.value);

            if (!isNaN(pixelSize) && pixelSize > 0) cameraConfig.pixel_size_um = pixelSize;
            if (!isNaN(camWidth) && camWidth > 0) cameraConfig.width_px = camWidth;
            if (!isNaN(camHeight) && camHeight > 0) cameraConfig.height_px = camHeight;

            const screenWidthMm = parseFloat(screenWidthMmInput.value);
            if (!isNaN(screenWidthMm) && screenWidthMm > 0) displayConfig.screen_width_mm = screenWidthMm;

            updateCalculations();
        }

        // Save a single field to the server with debouncing
        function saveField(inputElement) {
            const fieldId = inputElement.id;
            const mapping = fieldMapping[fieldId];
            if (!mapping) return;

            const { section, apiField } = mapping;
            const value = parseFloat(inputElement.value);

            // Clear existing timer for this field
            if (debounceTimers[fieldId]) {
                clearTimeout(debounceTimers[fieldId]);
            }

            // Validate the value
            if (isNaN(value)) {
                return;
            }

            // For non-latitude fields, require positive values
            if (apiField !== 'latitude' && value <= 0) {
                return;
            }

            // Debounce the server save
            debounceTimers[fieldId] = setTimeout(async () => {
                try {
                    const response = await fetch(`/api/config/${section}/${apiField}`, {
                        method: 'PATCH',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ value: value })
                    });
                    const data = await response.json();

                    if (data.status === 'ok' && data.calculated) {
                        applyCalculatedValues(data.calculated);
                    }
                } catch (error) {
                    console.error('Failed to save field:', error);
                }
            }, DEBOUNCE_DELAY);
        }

        // Event listeners - update on input for immediate feedback
        const allInputs = [latitudeInput, focalLengthInput, distanceInput, periodInput,
                          pixelSizeInput, cameraWidthInput, cameraHeightInput,
                          screenWidthMmInput];
        allInputs.forEach(input => {
            input.addEventListener('input', () => {
                updateLocalConfig();
                saveField(input);
            });
        });

        btnNext.addEventListener('click', async () => {
            if (currentStep < 4) {
                // Update step indicator
                document.getElementById(`step-${currentStep}`).classList.remove('active');
                document.getElementById(`step-${currentStep}`).classList.add('completed');

                // Hide current step content
                document.getElementById(`step-${currentStep}-content`).classList.remove('active');

                currentStep++;

                // Show new step content
                document.getElementById(`step-${currentStep}`).classList.add('active');
                document.getElementById(`step-${currentStep}-content`).classList.add('active');
                btnBack.disabled = false;

                // Notify server of mode change
                await fetch('/api/mode', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mode: currentStep })
                });

                // Load calibration points when entering step 3
                if (currentStep === 3) {
                    loadCalibrationPoints();
                } else {
                    updatePolynomialDisplay();  // Hide polynomial when leaving step 3
                }
            }
        });

        btnBack.addEventListener('click', async () => {
            if (currentStep > 1) {
                // Update step indicator
                document.getElementById(`step-${currentStep}`).classList.remove('active');

                // Hide current step content
                document.getElementById(`step-${currentStep}-content`).classList.remove('active');

                currentStep--;

                // Show previous step content
                document.getElementById(`step-${currentStep}`).classList.remove('completed');
                document.getElementById(`step-${currentStep}`).classList.add('active');
                document.getElementById(`step-${currentStep}-content`).classList.add('active');

                if (currentStep === 1) {
                    btnBack.disabled = true;
                }

                // Notify server of mode change
                await fetch('/api/mode', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mode: currentStep })
                });

                // Load calibration points when returning to step 3
                if (currentStep === 3) {
                    loadCalibrationPoints();
                } else {
                    updatePolynomialDisplay();  // Hide polynomial when leaving step 3
                }
            }
        });

        // Add click handlers for step indicator tabs
        for (let stepNum = 1; stepNum <= 4; stepNum++) {
            const stepElement = document.getElementById(`step-${stepNum}`);
            stepElement.style.cursor = 'pointer';
            stepElement.addEventListener('click', async () => {
                if (stepNum === currentStep) return;

                // Update all step indicators
                for (let i = 1; i <= 4; i++) {
                    const el = document.getElementById(`step-${i}`);
                    el.classList.remove('active', 'completed');
                    document.getElementById(`step-${i}-content`).classList.remove('active');

                    if (i < stepNum) {
                        el.classList.add('completed');
                    } else if (i === stepNum) {
                        el.classList.add('active');
                    }
                }

                // Show new step content
                document.getElementById(`step-${stepNum}-content`).classList.add('active');
                currentStep = stepNum;
                btnBack.disabled = (currentStep === 1);

                // Notify server of mode change
                await fetch('/api/mode', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mode: currentStep })
                });

                // Load calibration points when entering step 3
                if (stepNum === 3) {
                    loadCalibrationPoints();
                } else {
                    updatePolynomialDisplay();  // Hide polynomial when leaving step 3
                }
            });
        }

        // ===== Calibration Canvas =====
        const calibrationCanvas = document.getElementById('calibration-canvas');
        const calibrationCtx = calibrationCanvas.getContext('2d');
        const pointCountSpan = document.getElementById('point-count');
        const btnResetCalibration = document.getElementById('btn-reset-calibration');
        const btnDeleteLast = document.getElementById('btn-delete-last');

        let calibrationPoints = [];
        let screenWidth = 1920;  // Will be updated from config
        let screenHeight = 1080;
        let hoverDebounceTimer = null;
        const HOVER_DEBOUNCE_MS = 50;
        let selectedPointIndex = -1;  // -1 means no selection
        let polynomialCoeffs = null;  // [a, b, c, d] for ax³+bx²+cx+d

        const polynomialDisplay = document.getElementById('polynomial-display');
        const polynomialFormula = document.getElementById('polynomial-formula');

        // Format a number for display in polynomial
        function formatCoeff(val, isFirst) {
            const absVal = Math.abs(val);
            const sign = val >= 0 ? '+' : '-';
            const formatted = absVal.toExponential(3);
            if (isFirst) {
                return val >= 0 ? formatted : '-' + formatted;
            }
            return ` ${sign} ${formatted}`;
        }

        // Update polynomial display
        function updatePolynomialDisplay() {
            if (polynomialCoeffs && currentStep === 3) {
                const [a, b, c, d] = polynomialCoeffs;
                const formula = `y = ${formatCoeff(a, true)}x³${formatCoeff(b, false)}x²${formatCoeff(c, false)}x${formatCoeff(d, false)}`;
                polynomialFormula.textContent = formula;
                polynomialDisplay.style.display = 'block';
            } else {
                polynomialDisplay.style.display = 'none';
            }
        }

        // Initialize canvas with screen aspect ratio
        function initCalibrationCanvas() {
            // Get screen dimensions from display config (set during loadConfig)
            screenWidth = displayConfig.screen_width || 1920;
            screenHeight = displayConfig.screen_height || 1080;

            // Set canvas size maintaining aspect ratio
            const container = document.getElementById('calibration-canvas-container');
            const containerWidth = container.clientWidth - 4;  // Account for border
            const aspectRatio = screenHeight / screenWidth;
            const canvasHeight = containerWidth * aspectRatio;

            calibrationCanvas.width = containerWidth;
            calibrationCanvas.height = canvasHeight;

            drawCalibrationCanvas();
        }

        // Draw the calibration canvas
        function drawCalibrationCanvas() {
            const ctx = calibrationCtx;
            const width = calibrationCanvas.width;
            const height = calibrationCanvas.height;

            // Clear canvas with black background
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);

            // Draw grid (same as simulator)
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            const gridParts = 4;
            for (let i = 1; i < gridParts; i++) {
                const x = (width / gridParts) * i;
                const y = (height / gridParts) * i;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // Draw polynomial fit curve (red) if available
            if (polynomialCoeffs && calibrationPoints.length > 3) {
                const [a, b, c, d] = polynomialCoeffs;
                const xCoords = calibrationPoints.map(p => p[0]);
                const xMin = Math.min(...xCoords);
                const xMax = Math.max(...xCoords);

                ctx.strokeStyle = '#f00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                let started = false;
                for (let screenX = xMin; screenX <= xMax; screenX += 2) {
                    const screenY = a * screenX**3 + b * screenX**2 + c * screenX + d;
                    if (screenY >= 0 && screenY <= screenHeight) {
                        const canvasPoint = screenToCanvas(screenX, screenY);
                        if (!started) {
                            ctx.moveTo(canvasPoint.x, canvasPoint.y);
                            started = true;
                        } else {
                            ctx.lineTo(canvasPoint.x, canvasPoint.y);
                        }
                    }
                }
                ctx.stroke();
            }

            // Draw connecting line between points (orange)
            if (calibrationPoints.length > 1) {
                ctx.strokeStyle = '#ffa500';
                ctx.lineWidth = 2;
                ctx.beginPath();
                const firstPoint = screenToCanvas(calibrationPoints[0][0], calibrationPoints[0][1]);
                ctx.moveTo(firstPoint.x, firstPoint.y);
                for (let i = 1; i < calibrationPoints.length; i++) {
                    const point = screenToCanvas(calibrationPoints[i][0], calibrationPoints[i][1]);
                    ctx.lineTo(point.x, point.y);
                }
                ctx.stroke();
            }

            // Draw calibration points (crosshairs - green for normal, yellow for selected)
            calibrationPoints.forEach((point, index) => {
                const canvasPoint = screenToCanvas(point[0], point[1]);
                const isSelected = (index === selectedPointIndex);
                const color = isSelected ? '#ff0' : '#0f0';
                const crossSize = isSelected ? 10 : 6;

                // Draw crosshair
                ctx.strokeStyle = color;
                ctx.lineWidth = isSelected ? 2 : 1;
                ctx.beginPath();
                ctx.moveTo(canvasPoint.x - crossSize, canvasPoint.y);
                ctx.lineTo(canvasPoint.x + crossSize, canvasPoint.y);
                ctx.moveTo(canvasPoint.x, canvasPoint.y - crossSize);
                ctx.lineTo(canvasPoint.x, canvasPoint.y + crossSize);
                ctx.stroke();

                // Draw point number
                ctx.fillStyle = color;
                ctx.font = isSelected ? 'bold 14px sans-serif' : '12px sans-serif';
                ctx.fillText((index + 1).toString(), canvasPoint.x + 8, canvasPoint.y - 6);
            });

            // Update point count
            pointCountSpan.textContent = calibrationPoints.length;
        }

        // Convert screen coordinates to canvas coordinates
        function screenToCanvas(screenX, screenY) {
            return {
                x: (screenX / screenWidth) * calibrationCanvas.width,
                y: (screenY / screenHeight) * calibrationCanvas.height
            };
        }

        // Convert canvas coordinates to screen coordinates
        function canvasToScreen(canvasX, canvasY) {
            return {
                x: Math.round((canvasX / calibrationCanvas.width) * screenWidth),
                y: Math.round((canvasY / calibrationCanvas.height) * screenHeight)
            };
        }

        // Handle mouse move on canvas (debounced)
        calibrationCanvas.addEventListener('mousemove', (e) => {
            if (currentStep !== 3) return;

            if (hoverDebounceTimer) clearTimeout(hoverDebounceTimer);

            hoverDebounceTimer = setTimeout(() => {
                const rect = calibrationCanvas.getBoundingClientRect();
                const canvasX = e.clientX - rect.left;
                const canvasY = e.clientY - rect.top;
                const screenCoords = canvasToScreen(canvasX, canvasY);

                fetch('/api/calibration/hover', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ x: screenCoords.x, y: screenCoords.y })
                });
            }, HOVER_DEBOUNCE_MS);
        });

        // Handle click on canvas
        calibrationCanvas.addEventListener('click', async (e) => {
            if (currentStep !== 3) return;

            const rect = calibrationCanvas.getBoundingClientRect();
            const canvasX = e.clientX - rect.left;
            const canvasY = e.clientY - rect.top;
            const screenCoords = canvasToScreen(canvasX, canvasY);

            try {
                const response = await fetch('/api/calibration/click', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ x: screenCoords.x, y: screenCoords.y })
                });
                const data = await response.json();

                if (data.status === 'ok' && data.points) {
                    calibrationPoints = data.points;
                    polynomialCoeffs = data.polynomial || null;
                    // Auto-select the newly added point
                    selectedPointIndex = calibrationPoints.length - 1;
                    notifySelectedIndex();
                    drawCalibrationCanvas();
                    updatePolynomialDisplay();
                }
            } catch (error) {
                console.error('Failed to record calibration point:', error);
            }
        });

        // Handle reset button
        btnResetCalibration.addEventListener('click', async () => {
            try {
                const response = await fetch('/api/calibration/reset', {
                    method: 'DELETE'
                });
                const data = await response.json();

                if (data.status === 'ok') {
                    calibrationPoints = [];
                    polynomialCoeffs = null;
                    selectedPointIndex = -1;
                    notifySelectedIndex();
                    drawCalibrationCanvas();
                    updatePolynomialDisplay();
                }
            } catch (error) {
                console.error('Failed to reset calibration:', error);
            }
        });

        // Handle delete last button
        btnDeleteLast.addEventListener('click', async () => {
            if (calibrationPoints.length === 0) return;

            try {
                const response = await fetch('/api/calibration/last', {
                    method: 'DELETE'
                });
                const data = await response.json();

                if (data.status === 'ok') {
                    calibrationPoints = data.points;
                    polynomialCoeffs = data.polynomial || null;
                    // Adjust selected index if needed
                    if (selectedPointIndex >= calibrationPoints.length) {
                        selectedPointIndex = calibrationPoints.length - 1;
                        notifySelectedIndex();
                    }
                    drawCalibrationCanvas();
                    updatePolynomialDisplay();
                }
            } catch (error) {
                console.error('Failed to delete last point:', error);
            }
        });

        // Notify server of selected index change
        async function notifySelectedIndex() {
            try {
                await fetch('/api/calibration/select', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ index: selectedPointIndex })
                });
            } catch (error) {
                console.error('Failed to update selected index:', error);
            }
        }

        // Move selected point by dx, dy
        async function moveSelectedPoint(dx, dy) {
            if (selectedPointIndex < 0 || selectedPointIndex >= calibrationPoints.length) return;

            try {
                const response = await fetch(`/api/calibration/point/${selectedPointIndex}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ dx, dy })
                });
                const data = await response.json();

                if (data.status === 'ok' && data.points) {
                    calibrationPoints = data.points;
                    polynomialCoeffs = data.polynomial || null;
                    drawCalibrationCanvas();
                    updatePolynomialDisplay();
                }
            } catch (error) {
                console.error('Failed to move point:', error);
            }
        }

        // Select previous point (with wrap around)
        function selectPreviousPoint() {
            if (calibrationPoints.length === 0) return;
            if (selectedPointIndex <= 0) {
                selectedPointIndex = calibrationPoints.length - 1;
            } else {
                selectedPointIndex--;
            }
            notifySelectedIndex();
            drawCalibrationCanvas();
        }

        // Select next point (with wrap around)
        function selectNextPoint() {
            if (calibrationPoints.length === 0) return;
            if (selectedPointIndex < 0 || selectedPointIndex >= calibrationPoints.length - 1) {
                selectedPointIndex = 0;
            } else {
                selectedPointIndex++;
            }
            notifySelectedIndex();
            drawCalibrationCanvas();
        }

        // Keyboard handler for point manipulation
        document.addEventListener('keydown', (e) => {
            // Only handle keys when on calibration step
            if (currentStep !== 3) return;

            // Don't handle if focus is on an input element
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            let handled = false;

            switch (e.key) {
                // Movement keys: s=left, f=right, e=up, d=down (and arrow keys)
                case 's':
                case 'ArrowLeft':
                    moveSelectedPoint(-1, 0);
                    handled = true;
                    break;
                case 'f':
                case 'ArrowRight':
                    moveSelectedPoint(1, 0);
                    handled = true;
                    break;
                case 'e':
                case 'ArrowUp':
                    moveSelectedPoint(0, -1);
                    handled = true;
                    break;
                case 'd':
                case 'ArrowDown':
                    moveSelectedPoint(0, 1);
                    handled = true;
                    break;

                // Selection keys: q/PageUp=previous, a/PageDown=next
                case 'q':
                case 'PageUp':
                    selectPreviousPoint();
                    handled = true;
                    break;
                case 'a':
                case 'PageDown':
                    selectNextPoint();
                    handled = true;
                    break;
            }

            if (handled) {
                e.preventDefault();
            }
        });

        // Load existing calibration points
        async function loadCalibrationPoints() {
            try {
                const response = await fetch('/api/calibration/points');
                const data = await response.json();
                calibrationPoints = data.points || [];
                polynomialCoeffs = data.polynomial || null;
                initCalibrationCanvas();
                updatePolynomialDisplay();
            } catch (error) {
                console.error('Failed to load calibration points:', error);
                initCalibrationCanvas();
            }
        }

        // Initialize
        loadConfig();
    </script>
</body>
</html>
