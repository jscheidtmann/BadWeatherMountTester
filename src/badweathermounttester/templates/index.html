<!DOCTYPE html>
<html lang="{{ get_locale() }}">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ _('Bad Weather Mount Tester') }}</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, sans-serif;
            background-color: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            padding: 10px 15px;
            font-size: 17px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            color: #00d4ff;
            font-size: 1.4em;
        }

        .card {
            background-color: #16213e;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 10px;
        }

        .card h2 {
            margin-bottom: 8px;
            color: #00d4ff;
            font-size: 1em;
        }

        .form-group {
            margin-bottom: 8px;
        }

        .form-group:last-child {
            margin-bottom: 0;
        }

        .form-group label {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 2px;
            color: #aaa;
            font-size: 0.85em;
        }

        .info-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background-color: #444;
            color: #aaa;
            font-size: 11px;
            font-weight: bold;
            font-style: italic;
            font-family: Georgia, serif;
            cursor: help;
            flex-shrink: 0;
            position: relative;
        }

        .info-icon:hover {
            background-color: #00d4ff;
            color: #000;
        }

        .info-icon .tooltip {
            display: none;
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            background-color: #1a1a2e;
            border: 1px solid #00d4ff;
            border-radius: 6px;
            padding: 10px 12px;
            width: 280px;
            font-size: 13px;
            font-style: normal;
            font-weight: normal;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            color: #eee;
            line-height: 1.4;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        .info-icon .tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: #00d4ff;
        }

        .info-icon:hover .tooltip {
            display: block;
        }

        .form-group input {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #333;
            border-radius: 4px;
            background-color: #0f0f23;
            color: #eee;
            font-size: 17px;
        }

        .form-group input:focus {
            outline: none;
            border-color: #00d4ff;
        }

        .btn {
            display: inline-block;
            padding: 8px 16px;
            background-color: #00d4ff;
            color: #000;
            border: none;
            border-radius: 4px;
            font-size: 17px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .btn:hover {
            background-color: #00a8cc;
        }

        .btn:disabled {
            background-color: #555;
            cursor: not-allowed;
        }

        .btn-secondary {
            background-color: #444;
            color: #eee;
        }

        .btn-secondary:hover {
            background-color: #555;
        }

        .step-indicator {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .step {
            flex: 1;
            text-align: center;
            padding: 6px 4px;
            background-color: #0f0f23;
            margin: 0 3px;
            border-radius: 4px;
            color: #666;
            font-size: 0.85em;
        }

        .step.active {
            background-color: #00d4ff;
            color: #000;
        }

        .step.completed {
            background-color: #1b4332;
            color: #95d5b2;
        }

        .actions {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
        }

        .config-row {
            display: flex;
            gap: 12px;
            margin-bottom: 10px;
        }

        .config-row .card {
            flex: 1;
            margin-bottom: 0;
        }

        .calc-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px 16px;
        }

        .calc-grid p {
            margin: 0;
            font-size: 0.9em;
        }

        .screen-calc {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #333;
        }

        .screen-calc p {
            margin: 0 0 2px 0;
            font-size: 0.85em;
            color: #aaa;
        }

        .screen-calc p:last-child {
            margin-bottom: 0;
        }

        .instructions-card {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: #000;
            border: 2px solid #fbbf24;
            padding: 10px 14px;
        }

        .instructions-card h2 {
            color: #000;
            font-size: 0.95em;
            margin-bottom: 4px;
        }

        .instructions-card p {
            margin: 0 0 6px 0;
            font-size: 0.9em;
            font-weight: 500;
        }

        .instructions-card ol {
            margin: 0 0 6px 0;
            padding-left: 20px;
            font-size: 0.9em;
            font-weight: 500;
        }

        .instructions-card li {
            margin-bottom: 2px;
        }

        .instructions-card li:last-child {
            margin-bottom: 0;
        }

        .instructions-card > *:last-child {
            margin-bottom: 0;
        }

        .step-content {
            display: none;
        }

        .step-content.active {
            display: block;
        }

        .calibration-canvas-container {
            background-color: #000;
            border: 2px solid #333;
            border-radius: 4px;
            margin: 10px 0;
            cursor: crosshair;
            position: relative;
        }

        #calibration-canvas {
            display: block;
            width: 100%;
            height: auto;
        }

        .calibration-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 8px;
        }

        .calibration-info span {
            font-size: 0.9em;
            color: #aaa;
        }

        .calibration-buttons {
            display: flex;
            gap: 8px;
        }

        .ellipse-params {
            margin-top: 15px;
            padding: 12px;
            background-color: #1a1a2e;
            border: 1px solid #333;
            border-radius: 4px;
        }

        .ellipse-params h3 {
            margin: 0 0 10px 0;
            font-size: 1em;
            color: #00d4ff;
        }

        .params-table {
            width: 100%;
            font-size: 0.9em;
        }

        .params-table td {
            padding: 4px 8px;
        }

        .params-table td:nth-child(odd) {
            color: #aaa;
            text-align: right;
            width: 25%;
        }

        .params-table td:nth-child(even) {
            color: #fff;
            width: 25%;
        }

        .btn-small {
            padding: 4px 10px;
            font-size: 14px;
        }

        .btn-danger {
            background-color: #dc3545;
            color: #fff;
        }

        .btn-danger:hover {
            background-color: #c82333;
        }

        @media (max-width: 600px) {
            .config-row {
                flex-direction: column;
            }
            .config-row .card {
                margin-bottom: 10px;
            }
        }

        /* Simulation UI Styles */
        .simulation-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #666;
        }

        .status-dot.ready {
            background-color: #666;
        }

        .status-dot.running {
            background-color: #4caf50;
            animation: pulse 1s infinite;
        }

        .status-dot.paused {
            background-color: #ff9800;
        }

        .status-dot.complete {
            background-color: #2196f3;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .status-text {
            font-size: 1.1em;
            font-weight: 500;
        }

        .countdown {
            text-align: right;
        }

        .countdown-label {
            color: #aaa;
            font-size: 0.9em;
        }

        .countdown-time {
            font-size: 1.8em;
            font-weight: bold;
            font-family: monospace;
            color: #00d4ff;
        }

        .progress-container {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .progress-bar {
            flex: 1;
            height: 20px;
            background-color: #0f0f23;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #333;
            cursor: pointer;
        }

        .progress-bar:hover {
            border-color: #00d4ff;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #4caf50);
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-percent {
            font-size: 1em;
            font-weight: bold;
            min-width: 50px;
            text-align: right;
        }

        .simulation-info {
            text-align: center;
            margin-bottom: 12px;
            color: #aaa;
        }

        .simulation-info p {
            margin: 0;
        }

        .simulation-buttons {
            display: flex;
            justify-content: center;
            gap: 12px;
        }

        .media-controls {
            gap: 8px;
        }

        .btn-media {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 1.4em;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #333;
            color: #fff;
            border: 2px solid #555;
            transition: all 0.2s;
        }

        .btn-media:hover {
            background-color: #444;
            border-color: #00d4ff;
        }

        .btn-media:disabled {
            background-color: #222;
            color: #555;
            border-color: #333;
            cursor: not-allowed;
        }

        .btn-media.btn-play {
            width: 60px;
            height: 60px;
            font-size: 1.6em;
            background-color: #00d4ff;
            color: #000;
            border-color: #00d4ff;
        }

        .btn-media.btn-play:hover {
            background-color: #00a8cc;
            border-color: #00a8cc;
        }

        .btn-media.btn-play.playing {
            background-color: #ff9800;
            border-color: #ff9800;
        }

        .btn-media.btn-play.playing:hover {
            background-color: #f57c00;
            border-color: #f57c00;
        }

        .btn-media.btn-play:disabled {
            background-color: #555;
            color: #888;
            border-color: #555;
        }

        /* Velocity measurement styles */
        .stopwatch-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 15px;
        }

        .stopwatch-display {
            text-align: center;
            flex: 1;
        }

        .stopwatch-time {
            font-family: 'Courier New', monospace;
            font-size: 2.2em;
            font-weight: bold;
            color: #00d4ff;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.3);
        }

        .stopwatch-buttons {
            display: flex;
            gap: 8px;
        }

        .btn-stopwatch {
            padding: 10px 20px;
            font-size: 1em;
            min-width: 80px;
        }

        .btn-stopwatch.btn-start {
            background-color: #4caf50;
            color: white;
        }

        .btn-stopwatch.btn-start:hover {
            background-color: #45a049;
        }

        .btn-stopwatch.btn-stop {
            background-color: #f44336;
            color: white;
        }

        .btn-stopwatch.btn-stop:hover {
            background-color: #da190b;
        }

        .stripe-selector {
            display: flex;
            gap: 6px;
        }

        .stripe-btn {
            padding: 10px 18px;
            border: 2px solid #444;
            border-radius: 4px;
            background-color: #222;
            color: #888;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.95em;
        }

        .stripe-btn:hover {
            border-color: #666;
            color: #aaa;
        }

        .stripe-btn.selected {
            border-color: #00d4ff;
            background-color: #0a2a3a;
            color: #00d4ff;
        }

        .stripe-btn.recorded {
            border-color: #4caf50;
            color: #4caf50;
        }

        .stripe-btn.selected.recorded {
            border-color: #00d4ff;
            background-color: #0a2a3a;
        }

        .measurements-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .measurement-card {
            background-color: #0f0f23;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 12px;
            text-align: center;
        }

        .measurement-card.has-value {
            border-color: #4caf50;
        }

        .measurement-card h4 {
            margin: 0 0 8px 0;
            color: #aaa;
            font-size: 0.9em;
        }

        .measurement-value {
            font-family: 'Courier New', monospace;
            font-size: 1.4em;
            font-weight: bold;
            color: #fff;
            margin-bottom: 4px;
        }

        .measurement-velocity {
            font-size: 0.9em;
            color: #4caf50;
            margin-bottom: 8px;
        }

        .measurement-card .btn-clear {
            padding: 4px 12px;
            font-size: 0.8em;
        }

        .velocity-info {
            text-align: center;
            margin-top: 15px;
            padding: 10px;
            background-color: #1a1a2e;
            border-radius: 4px;
        }

        .velocity-info p {
            margin: 4px 0;
            color: #aaa;
        }

        .velocity-info .calculated-velocity {
            font-size: 1.1em;
            color: #4caf50;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>{{ _('Bad Weather Mount Tester') }}</h1>

        <div class="step-indicator">
            <div class="step active" id="step-1">1. {{ _('Configure') }}</div>
            <div class="step" id="step-2">2. {{ _('Align') }}</div>
            <div class="step" id="step-3">3. {{ _('Calibrate') }}</div>
            <div class="step" id="step-4">4. {{ _('Velocity') }}</div>
            <div class="step" id="step-5">5. {{ _('Measure') }}</div>
        </div>

        <!-- Step 1: Configure -->
        <div class="step-content active" id="step-1-content">
            <div class="config-row">
                <div class="card" id="config-card">
                    <h2>{{ _('Mount Configuration') }}</h2>
                    <div class="form-group">
                        <label for="latitude">{{ _('Latitude (degrees)') }}
                            <span class="info-icon">i<span class="tooltip">{{ _('Enter the latitude that your mount is configured for. This affects the geometry calculations for the simulated star movement.') }}</span></span>
                        </label>
                        <input type="number" id="latitude" step="0.1" value="0">
                    </div>
                    <div class="form-group">
                        <label for="focal-length">{{ _('Guide Scope Focal Length (mm)') }}
                            <span class="info-icon">i<span class="tooltip">{{ _('Enter the focal length of your guide scope. Since the scope is not focused to infinity, BWMT will calculate an effective focal length for PHD2.') }}</span></span>
                        </label>
                        <input type="number" id="focal-length" step="1" value="200">
                    </div>
                    <div class="form-group">
                        <label for="distance">{{ _('Distance to Screen (m)') }}
                            <span class="info-icon">i<span class="tooltip">{{ _('The distance between mount and simulator screen. At least 5m is recommended for best accuracy, though 3.5m minimum is possible.') }}</span></span>
                        </label>
                        <input type="number" id="distance" step="0.1" value="5">
                    </div>
                    <div class="form-group">
                        <label for="period">{{ _('Mount Main Period (seconds)') }}
                            <span class="info-icon">i<span class="tooltip">{{ _('For worm gear mounts: How long does it take for the worm to rotate once? This information is provided by the manufacturer of your mount.') }}</span></span>
                        </label>
                        <input type="number" id="period" step="1" value="480">
                    </div>
                </div>

                <div class="card" id="camera-card">
                    <h2>{{ _('Guiding Camera') }}</h2>
                    <div class="form-group">
                        <label for="pixel-size">{{ _('Pixel Size (micrometer)') }}
                            <span class="info-icon">i<span class="tooltip">{{ _('The pixel pitch of your guide camera sensor. This is typically found in the camera specifications (e.g., 2.4µm, 3.75µm).') }}</span></span>
                        </label>
                        <input type="number" id="pixel-size" step="0.01" value="3.75">
                    </div>
                    <div class="form-group">
                        <label for="camera-width">{{ _('Width (pixels)') }}
                            <span class="info-icon">i<span class="tooltip">{{ _('The number of pixels in the horizontal direction of your guide camera sensor.') }}</span></span>
                        </label>
                        <input type="number" id="camera-width" step="1" value="1280">
                    </div>
                    <div class="form-group">
                        <label for="camera-height">{{ _('Height (pixels)') }}
                            <span class="info-icon">i<span class="tooltip">{{ _('The number of pixels in the vertical direction of your guide camera sensor.') }}</span></span>
                        </label>
                        <input type="number" id="camera-height" step="1" value="960">
                    </div>
                    <div class="screen-calc">
                        <p>{{ _('Resolution:') }}</p>
                        <p><strong id="camera-resolution-arcsec">--</strong> arcsec/px</p>
                    </div>
                </div>

                <div class="card" id="screen-card">
                    <h2>{{ _('Screen') }}</h2>
                    <div class="form-group">
                        <label for="screen-width-mm">{{ _('Screen Width (mm)') }}
                            <span class="info-icon">i<span class="tooltip">{{ _('The physical width of your simulator screen in millimeters. Measure the visible display area, not the bezel. This is used to calculate the pixel pitch.') }}</span></span>
                        </label>
                        <input type="number" id="screen-width-mm" step="1" value="527">
                    </div>
                    <div class="screen-calc">
                        <p>{{ _('Pixel Pitch:') }}</p>
                        <p><strong id="pixel-pitch-mm">--</strong> mm/px</p>
                        <p><strong id="pixel-pitch-arcsec">--</strong> arcsec/px</p>
                    </div>
                </div>
            </div>

            <div class="card" id="info-card">
                <h2>{{ _('Calculated Values') }}</h2>
                <div class="calc-grid">
                    <p>{{ _('Effective FL for PHD2:') }} <strong id="effective-focal">--</strong> mm</p>
                    <p>{{ _('Measurement duration:') }} ~<strong id="duration">--</strong> {{ _('minutes') }}</p>
                    <p>{{ _('Recommended Binning:') }} <strong id="binning">--</strong>x</p>
                    <p>{{ _('Area on Simulator:') }} <strong id="area-width">--</strong> x <strong id="area-height">--</strong> mm</p>
                </div>
            </div>

            <div class="card instructions-card">
                <h2>{{ _('Instructions') }}</h2>
                <p>{{ _('Fill in the values above, then set up PHD2 as follows:') }}</p>
                <ol>
                    <li>{{ _('Create a new guiding profile in PHD2 with the Effective FL and Binning values as listed above.') }}</li>
                    <li>{{ _('Disable multi-star guiding (we use one simulated star).') }}</li>
                    <li>{{ _('Start looping in PHD2.') }}</li>
                    <li>{{ _('From the Tools menu, enable the cross in the camera display.') }}</li>
                    <li>{{ _('Point the mount at the simulator display, focus and locate the cross, by following the arrows') }}</li>
                    <li>{{ _('While on the way orient the simulator display such (grid), that you\'re roughly in focus all over the simulator display') }}</li>
                </ol>
                <p>{{ _('Then press "Next" to start aligning the mount.') }}</p>
            </div>
        </div>

        <!-- Step 2: Align -->
        <div class="step-content" id="step-2-content">
            <div class="card instructions-card">
                <h2>{{ _('Instructions') }}</h2>
                <p>{{ _('Rotate the mount in Azimuth, so that when going from left-to-right, the red line will be visible when rotating the mount only in RA.') }}</p>
                <p>{{ _('Press "Next" when aligned, or "Back" to return to configuration.') }}</p>
            </div>
        </div>

        <!-- Step 3: Calibrate -->
        <div class="step-content" id="step-3-content">
            <div class="card instructions-card">
                <h2>{{ _('Instructions') }}</h2>
                <ol>
                    <li>{{ _('Look at PHD2 to see where the white crosshair appears on the simulator screen.') }}</li>
                    <li>{{ _('Click on the preview below at that location to record a point.') }}</li>
                    <li>{{ _('Fine-tune the point position using keyboard: Arrow keys or S/E/D/F (left/up/down/right).') }}</li>
                    <li>{{ _('Move the mount in RA a few pixels, then repeat steps 1-3.') }}</li>
                    <li>{{ _('Continue until you have traced across the entire screen.') }}</li>
                </ol>
                <p><strong>{{ _('Keyboard:') }}</strong> {{ _('Arrows/S/E/D/F = move 1px | Q/PgUp = previous point | A/PgDn = next point') }}</p>
                <p>{{ _('The selected point is shown in yellow. New points are auto-selected.') }}</p>
            </div>

            <div class="card">
                <h2>{{ _('Calibration Preview') }}</h2>
                <div class="calibration-canvas-container" id="calibration-canvas-container">
                    <canvas id="calibration-canvas"></canvas>
                </div>
                <div class="calibration-info">
                    <span>{{ _('Points collected:') }} <strong id="point-count">0</strong></span>
                    <div class="calibration-buttons">
                        <button class="btn btn-danger btn-small" id="btn-reset-calibration">{{ _('Reset') }}</button>
                        <button class="btn btn-secondary btn-small" id="btn-delete-selected">{{ _('Delete Selected') }}</button>
                    </div>
                </div>
                <div class="ellipse-params" id="ellipse-params" style="display: none;">
                    <h3>{{ _('Fitted Ellipse') }}</h3>
                    <table class="params-table">
                        <tr>
                            <td>{{ _('Center X:') }}</td>
                            <td><strong id="ellipse-center-x">--</strong> m</td>
                            <td>{{ _('Axis a:') }}</td>
                            <td><strong id="ellipse-semi-major">--</strong> m</td>
                        </tr>
                        <tr>
                            <td>{{ _('Center Y:') }}</td>
                            <td><strong id="ellipse-center-y">--</strong> m</td>
                            <td>{{ _('Axis b:') }}</td>
                            <td><strong id="ellipse-semi-minor">--</strong> m</td>
                        </tr>
                    </table>
                </div>
            </div>
        </div>

        <!-- Step 4: Velocity Measurement -->
        <div class="step-content" id="step-4-content">
            <div class="card instructions-card">
                <h2>{{ _('Instructions') }}</h2>
                <ol>
                    <li>{{ _('Three vertical stripes are now displayed on the simulator screen.') }}</li>
                    <li>{{ _('Select a stripe below (Left, Middle, or Right).') }}</li>
                    <li>{{ _('Move the mount until the star is about to enter the stripe.') }}</li>
                    <li>{{ _('Press Start when the star enters the stripe, Stop when it exits.') }}</li>
                    <li>{{ _('Record the time for each stripe to validate the calculated velocity.') }}</li>
                </ol>
                <p>{{ _('This step verifies that the mount moves at the expected sidereal rate.') }}</p>
            </div>

            <div class="card">
                <h2>{{ _('Stopwatch') }}</h2>
                <div class="stopwatch-row">
                    <div class="stripe-selector">
                        <button class="stripe-btn selected" id="stripe-left" data-stripe="left">{{ _('Left') }}</button>
                        <button class="stripe-btn" id="stripe-middle" data-stripe="middle">{{ _('Middle') }}</button>
                        <button class="stripe-btn" id="stripe-right" data-stripe="right">{{ _('Right') }}</button>
                    </div>
                    <div class="stopwatch-display">
                        <span class="stopwatch-time" id="stopwatch-time">00:00.000</span>
                    </div>
                    <div class="stopwatch-buttons">
                        <button class="btn btn-stopwatch btn-start" id="btn-stopwatch-toggle">{{ _('Start') }}</button>
                        <button class="btn btn-stopwatch btn-secondary" id="btn-stopwatch-reset">{{ _('Reset') }}</button>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>{{ _('Recorded Times') }}</h2>
                <div class="measurements-grid">
                    <div class="measurement-card" id="measurement-left">
                        <h4>{{ _('Left Stripe') }}</h4>
                        <div class="measurement-value" id="value-left">--:--</div>
                        <div class="measurement-velocity" id="velocity-left">-- px/s</div>
                        <button class="btn btn-danger btn-clear" id="clear-left" disabled>{{ _('Clear') }}</button>
                    </div>
                    <div class="measurement-card" id="measurement-middle">
                        <h4>{{ _('Middle Stripe') }}</h4>
                        <div class="measurement-value" id="value-middle">--:--</div>
                        <div class="measurement-velocity" id="velocity-middle">-- px/s</div>
                        <button class="btn btn-danger btn-clear" id="clear-middle" disabled>{{ _('Clear') }}</button>
                    </div>
                    <div class="measurement-card" id="measurement-right">
                        <h4>{{ _('Right Stripe') }}</h4>
                        <div class="measurement-value" id="value-right">--:--</div>
                        <div class="measurement-velocity" id="velocity-right">-- px/s</div>
                        <button class="btn btn-danger btn-clear" id="clear-right" disabled>{{ _('Clear') }}</button>
                    </div>
                </div>

                <div class="velocity-info" id="velocity-info">
                    <p>{{ _('Stripe width:') }} <strong id="stripe-width">--</strong> px | {{ _('Expected:') }} <strong id="expected-crossing">--</strong>s</p>
                    <p class="calculated-velocity" id="max-velocity-text" style="display: none;">
                        {{ _('Max measured velocity:') }} <strong id="max-velocity">--</strong> px/s
                    </p>
                </div>
            </div>
        </div>

        <!-- Step 5: Measure -->
        <div class="step-content" id="step-5-content">
            <div class="card instructions-card">
                <h2>{{ _('Instructions') }}</h2>
                <ol>
                    <li>{{ _('Move the mount back to the starting position (left side of screen).') }}</li>
                    <li>{{ _('In PHD2, center the simulated star and start guiding.') }}</li>
                    <li>{{ _('Press "Start Simulation" below to begin the star movement.') }}</li>
                    <li>{{ _('Wait until the simulation completes (the star crosses the screen).') }}</li>
                    <li>{{ _('Stop guiding in PHD2 and analyze the log with PHD2 Log Viewer.') }}</li>
                </ol>
            </div>

            <div class="card">
                <h2>{{ _('Simulation Control') }}</h2>
                <div class="simulation-status" id="simulation-status">
                    <div class="status-indicator" id="status-indicator">
                        <span class="status-dot" id="status-dot"></span>
                        <span class="status-text" id="status-text">{{ _('Ready') }}</span>
                    </div>
                    <div class="countdown" id="countdown">
                        <span class="countdown-label">{{ _('Remaining:') }}</span>
                        <span class="countdown-time" id="countdown-time">--:--</span>
                    </div>
                </div>

                <div class="progress-container">
                    <div class="progress-bar" id="progress-bar">
                        <div class="progress-fill" id="progress-fill"></div>
                    </div>
                    <span class="progress-percent" id="progress-percent">0%</span>
                </div>

                <div class="simulation-info">
                    <p>{{ _('Elapsed:') }} <strong id="elapsed-time">0:00</strong> | {{ _('Total:') }} <strong id="total-time">--:--</strong></p>
                    <p id="velocity-source-info" style="font-size: 0.85em; margin-top: 4px;">
                        {{ _('Velocity:') }} <strong id="sim-current-velocity">--</strong> px/s
                        (<span id="velocity-source-label">--</span>)
                    </p>
                </div>

                <div class="simulation-buttons media-controls">
                    <button class="btn btn-media" id="btn-reset-sim" title="{{ _('Reset to start') }}">⏮</button>
                    <button class="btn btn-media" id="btn-skip-back" title="{{ _('Skip back 10s') }}">⏪</button>
                    <button class="btn btn-media btn-play" id="btn-play-pause" title="{{ _('Play/Pause') }}">▶</button>
                    <button class="btn btn-media" id="btn-skip-forward" title="{{ _('Skip forward 10s') }}">⏩</button>
                    <button class="btn btn-media" id="btn-stop-sim" title="{{ _('Stop') }}">⏹</button>
                </div>
            </div>
        </div>

        <div class="actions">
            <button class="btn btn-secondary" id="btn-back" disabled>{{ _('Back') }}</button>
            <button class="btn" id="btn-next">{{ _('Next') }}</button>
        </div>
    </div>

    <script>
        // State management
        let currentStep = 1;
        let mountConfig = {
            latitude: 0,
            focal_length_mm: 200,
            distance_to_screen_m: 5,
            main_period_seconds: 480
        };
        let cameraConfig = {
            pixel_size_um: 3.75,
            width_px: 1280,
            height_px: 960
        };
        let displayConfig = {
            screen_width_mm: 527,
            screen_width: 1920,
            screen_height: 1080
        };

        // Debounce timers for each field
        const debounceTimers = {};
        const DEBOUNCE_DELAY = 300; // milliseconds

        // DOM elements - Mount
        const latitudeInput = document.getElementById('latitude');
        const focalLengthInput = document.getElementById('focal-length');
        const distanceInput = document.getElementById('distance');
        const periodInput = document.getElementById('period');

        // DOM elements - Camera
        const pixelSizeInput = document.getElementById('pixel-size');
        const cameraWidthInput = document.getElementById('camera-width');
        const cameraHeightInput = document.getElementById('camera-height');

        // DOM elements - Camera calculated
        const cameraResolutionArcsecSpan = document.getElementById('camera-resolution-arcsec');

        // DOM elements - Screen
        const screenWidthMmInput = document.getElementById('screen-width-mm');
        const pixelPitchMmSpan = document.getElementById('pixel-pitch-mm');
        const pixelPitchArcsecSpan = document.getElementById('pixel-pitch-arcsec');

        // DOM elements - Calculated values
        const effectiveFocalSpan = document.getElementById('effective-focal');
        const durationSpan = document.getElementById('duration');
        const binningSpan = document.getElementById('binning');
        const areaWidthSpan = document.getElementById('area-width');
        const areaHeightSpan = document.getElementById('area-height');
        const btnBack = document.getElementById('btn-back');
        const btnNext = document.getElementById('btn-next');

        // Field mapping: input element id -> {section, apiField}
        const fieldMapping = {
            'latitude': { section: 'mount', apiField: 'latitude' },
            'focal-length': { section: 'mount', apiField: 'focal_length_mm' },
            'distance': { section: 'mount', apiField: 'distance_to_screen_m' },
            'period': { section: 'mount', apiField: 'main_period_seconds' },
            'pixel-size': { section: 'camera', apiField: 'pixel_size_um' },
            'camera-width': { section: 'camera', apiField: 'width_px' },
            'camera-height': { section: 'camera', apiField: 'height_px' },
            'screen-width-mm': { section: 'display', apiField: 'screen_width_mm' }
        };

        // Load initial config from server
        async function loadConfig() {
            try {
                const response = await fetch('/api/config');
                const data = await response.json();
                mountConfig = data.mount;
                cameraConfig = data.camera;
                displayConfig = {
                    ...displayConfig,
                    ...data.display
                };
                updateInputs();
                updateCalculations();
            } catch (error) {
                console.error('Failed to load config:', error);
            }
        }

        function updateInputs() {
            latitudeInput.value = mountConfig.latitude;
            focalLengthInput.value = mountConfig.focal_length_mm;
            distanceInput.value = mountConfig.distance_to_screen_m;
            periodInput.value = mountConfig.main_period_seconds;

            pixelSizeInput.value = cameraConfig.pixel_size_um;
            cameraWidthInput.value = cameraConfig.width_px;
            cameraHeightInput.value = cameraConfig.height_px;

            screenWidthMmInput.value = displayConfig.screen_width_mm;
        }

        function updateCalculations() {
            // Calculate effective focal length
            const fl = mountConfig.focal_length_mm / 1000; // Convert to meters
            const dist = mountConfig.distance_to_screen_m;
            let effectiveFL = 0;

            if (dist > fl && dist > 0 && mountConfig.focal_length_mm > 0) {
                effectiveFL = (mountConfig.focal_length_mm * dist) / (dist - fl);
                effectiveFocalSpan.textContent = effectiveFL.toFixed(1);
            } else {
                effectiveFocalSpan.textContent = '--';
            }

            // Camera resolution in arcsec/pixel
            if (effectiveFL > 0 && cameraConfig.pixel_size_um > 0) {
                const cameraResolutionArcsec = 206.265 * cameraConfig.pixel_size_um / effectiveFL;
                cameraResolutionArcsecSpan.textContent = cameraResolutionArcsec.toFixed(2);
            } else {
                cameraResolutionArcsecSpan.textContent = '--';
            }

            // Screen pixel pitch calculations
            const screenWidthMm = displayConfig.screen_width_mm;
            const screenWidthPx = displayConfig.screen_width;

            if (screenWidthMm > 0 && screenWidthPx > 0) {
                // Pixel pitch in mm/pixel
                const pixelPitchMm = screenWidthMm / screenWidthPx;
                pixelPitchMmSpan.textContent = pixelPitchMm.toFixed(3);

                // Pixel pitch in arcsec/pixel (angular size as seen from mount)
                if (dist > 0) {
                    // angle = size / distance, convert to arcsec (* 206265)
                    const pixelPitchArcsec = (pixelPitchMm / (dist * 1000)) * 206265;
                    pixelPitchArcsecSpan.textContent = pixelPitchArcsec.toFixed(2);
                } else {
                    pixelPitchArcsecSpan.textContent = '--';
                }
            } else {
                pixelPitchMmSpan.textContent = '--';
                pixelPitchArcsecSpan.textContent = '--';
            }

            // Duration is based on sidereal rate and pixel pitch
            if (screenWidthMm > 0 && screenWidthPx > 0 && dist > 0) {
                const pixelPitchMm = screenWidthMm / screenWidthPx;
                const pixelPitchArcsec = (pixelPitchMm / (dist * 1000)) * 206265;
                const durationMinutes = pixelPitchArcsec * screenWidthPx / 15.0 / 60.0; // Assuming 15 arcsec/sec sidereal rate and convert to minutes;
                durationSpan.textContent = durationMinutes.toFixed(1);
            } else {
                durationSpan.textContent = '--';
            }

            // Camera and display dependent calculations
            if (effectiveFL > 0 && cameraConfig.pixel_size_um > 0 && dist > 0 && screenWidthPx > 0) {
                // Binning: 10 camera pixel should match ~1 simulator pixel
                // Camera pixel projected onto screen = (pixel_size_um * dist) / effective_fl mm
                // Screen pixel size = screen_width_mm / screen_width_px mm
                const cameraPixelOnScreen = (cameraConfig.pixel_size_um * dist) / effectiveFL;
                const screenPixelSize = screenWidthMm / screenWidthPx;
                const recommendedBinning = Math.max(1, Math.round(screenPixelSize / 10.0 / cameraPixelOnScreen));
                binningSpan.textContent = recommendedBinning;

                // Area on simulator (physical size in mm)
                const sensorWidthMm = (cameraConfig.width_px * cameraConfig.pixel_size_um) / 1000;
                const sensorHeightMm = (cameraConfig.height_px * cameraConfig.pixel_size_um) / 1000;
                const areaWidthMm = (sensorWidthMm * dist * 1000) / effectiveFL;
                const areaHeightMm = (sensorHeightMm * dist * 1000) / effectiveFL;
                areaWidthSpan.textContent = areaWidthMm.toFixed(1);
                areaHeightSpan.textContent = areaHeightMm.toFixed(1);
            } else {
                binningSpan.textContent = '--';
                areaWidthSpan.textContent = '--';
                areaHeightSpan.textContent = '--';
            }
        }

        // Update calculated values from server response
        function applyCalculatedValues(calculated) {
            if (calculated.effective_focal_length !== undefined) {
                effectiveFocalSpan.textContent = calculated.effective_focal_length || '--';
            }
            if (calculated.duration_minutes !== undefined) {
                durationSpan.textContent = calculated.duration_minutes || '--';
            }
            if (calculated.camera_resolution_arcsec !== undefined) {
                cameraResolutionArcsecSpan.textContent = calculated.camera_resolution_arcsec || '--';
            }
            if (calculated.recommended_binning !== undefined) {
                binningSpan.textContent = calculated.recommended_binning || '--';
            }
            if (calculated.area_width_mm !== undefined && calculated.area_height_mm !== undefined) {
                areaWidthSpan.textContent = calculated.area_width_mm || '--';
                areaHeightSpan.textContent = calculated.area_height_mm || '--';
            }
            if (calculated.pixel_pitch_mm !== undefined) {
                pixelPitchMmSpan.textContent = calculated.pixel_pitch_mm || '--';
            }
            if (calculated.pixel_pitch_arcsec !== undefined) {
                pixelPitchArcsecSpan.textContent = calculated.pixel_pitch_arcsec || '--';
            }
        }

        // Update local config from input values and recalculate
        function updateLocalConfig() {
            const lat = parseFloat(latitudeInput.value);
            const fl = parseFloat(focalLengthInput.value);
            const dist = parseFloat(distanceInput.value);
            const period = parseFloat(periodInput.value);

            if (!isNaN(lat)) mountConfig.latitude = lat;
            if (!isNaN(fl) && fl > 0) mountConfig.focal_length_mm = fl;
            if (!isNaN(dist) && dist > 0) mountConfig.distance_to_screen_m = dist;
            if (!isNaN(period) && period > 0) mountConfig.main_period_seconds = period;

            const pixelSize = parseFloat(pixelSizeInput.value);
            const camWidth = parseInt(cameraWidthInput.value);
            const camHeight = parseInt(cameraHeightInput.value);

            if (!isNaN(pixelSize) && pixelSize > 0) cameraConfig.pixel_size_um = pixelSize;
            if (!isNaN(camWidth) && camWidth > 0) cameraConfig.width_px = camWidth;
            if (!isNaN(camHeight) && camHeight > 0) cameraConfig.height_px = camHeight;

            const screenWidthMm = parseFloat(screenWidthMmInput.value);
            if (!isNaN(screenWidthMm) && screenWidthMm > 0) displayConfig.screen_width_mm = screenWidthMm;

            updateCalculations();
        }

        // Save a single field to the server with debouncing
        function saveField(inputElement) {
            const fieldId = inputElement.id;
            const mapping = fieldMapping[fieldId];
            if (!mapping) return;

            const { section, apiField } = mapping;
            const value = parseFloat(inputElement.value);

            // Clear existing timer for this field
            if (debounceTimers[fieldId]) {
                clearTimeout(debounceTimers[fieldId]);
            }

            // Validate the value
            if (isNaN(value)) {
                return;
            }

            // For non-latitude fields, require positive values
            if (apiField !== 'latitude' && value <= 0) {
                return;
            }

            // Debounce the server save
            debounceTimers[fieldId] = setTimeout(async () => {
                try {
                    const response = await fetch(`/api/config/${section}/${apiField}`, {
                        method: 'PATCH',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ value: value })
                    });
                    const data = await response.json();

                    if (data.status === 'ok' && data.calculated) {
                        applyCalculatedValues(data.calculated);
                    }
                } catch (error) {
                    console.error('Failed to save field:', error);
                }
            }, DEBOUNCE_DELAY);
        }

        // Event listeners - update on input for immediate feedback
        const allInputs = [latitudeInput, focalLengthInput, distanceInput, periodInput,
                          pixelSizeInput, cameraWidthInput, cameraHeightInput,
                          screenWidthMmInput];
        allInputs.forEach(input => {
            input.addEventListener('input', () => {
                updateLocalConfig();
                saveField(input);
            });
        });

        btnNext.addEventListener('click', async () => {
            if (currentStep < 5) {
                // Update step indicator
                document.getElementById(`step-${currentStep}`).classList.remove('active');
                document.getElementById(`step-${currentStep}`).classList.add('completed');

                // Hide current step content
                document.getElementById(`step-${currentStep}-content`).classList.remove('active');

                currentStep++;

                // Show new step content
                document.getElementById(`step-${currentStep}`).classList.add('active');
                document.getElementById(`step-${currentStep}-content`).classList.add('active');
                btnBack.disabled = false;

                // Notify server of mode change
                await fetch('/api/mode', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mode: currentStep })
                });

                // Load calibration points when entering step 3
                if (currentStep === 3) {
                    loadCalibrationPoints();
                } else {
                    updateEllipseDisplay();  // Hide when leaving step 3
                }

                // Setup velocity measurement when entering step 4
                if (currentStep === 4) {
                    setupVelocityMeasurement();
                }
            }
        });

        btnBack.addEventListener('click', async () => {
            if (currentStep > 1) {
                // Update step indicator
                document.getElementById(`step-${currentStep}`).classList.remove('active');

                // Hide current step content
                document.getElementById(`step-${currentStep}-content`).classList.remove('active');

                currentStep--;

                // Show previous step content
                document.getElementById(`step-${currentStep}`).classList.remove('completed');
                document.getElementById(`step-${currentStep}`).classList.add('active');
                document.getElementById(`step-${currentStep}-content`).classList.add('active');

                if (currentStep === 1) {
                    btnBack.disabled = true;
                }

                // Notify server of mode change
                await fetch('/api/mode', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mode: currentStep })
                });

                // Load calibration points when returning to step 3
                if (currentStep === 3) {
                    loadCalibrationPoints();
                } else {
                    updateEllipseDisplay();  // Hide when leaving step 3
                }

                // Setup velocity measurement when returning to step 4
                if (currentStep === 4) {
                    setupVelocityMeasurement();
                }
            }
        });

        // Add click handlers for step indicator tabs
        for (let stepNum = 1; stepNum <= 5; stepNum++) {
            const stepElement = document.getElementById(`step-${stepNum}`);
            stepElement.style.cursor = 'pointer';
            stepElement.addEventListener('click', async () => {
                if (stepNum === currentStep) return;

                // Update all step indicators
                for (let i = 1; i <= 5; i++) {
                    const el = document.getElementById(`step-${i}`);
                    el.classList.remove('active', 'completed');
                    document.getElementById(`step-${i}-content`).classList.remove('active');

                    if (i < stepNum) {
                        el.classList.add('completed');
                    } else if (i === stepNum) {
                        el.classList.add('active');
                    }
                }

                // Show new step content
                document.getElementById(`step-${stepNum}-content`).classList.add('active');
                currentStep = stepNum;
                btnBack.disabled = (currentStep === 1);

                // Notify server of mode change
                await fetch('/api/mode', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mode: currentStep })
                });

                // Load calibration points when entering step 3
                if (stepNum === 3) {
                    loadCalibrationPoints();
                } else {
                    updateEllipseDisplay();  // Hide when leaving step 3
                }

                // Setup velocity measurement when entering step 4
                if (stepNum === 4) {
                    setupVelocityMeasurement();
                }
            });
        }

        // ===== Calibration Canvas =====
        const calibrationCanvas = document.getElementById('calibration-canvas');
        const calibrationCtx = calibrationCanvas.getContext('2d');
        const pointCountSpan = document.getElementById('point-count');
        const btnResetCalibration = document.getElementById('btn-reset-calibration');
        const btnDeleteSelected = document.getElementById('btn-delete-selected');

        let calibrationPoints = [];
        let screenWidth = 1920;  // Will be updated from config
        let screenHeight = 1080;
        let hoverDebounceTimer = null;
        const HOVER_DEBOUNCE_MS = 50;
        let selectedPointIndex = -1;  // -1 means no selection
        let ellipseParams = null;  // Ellipse fit parameters

        // Ellipse display elements
        const ellipseParamsDiv = document.getElementById('ellipse-params');
        const ellipseCenterX = document.getElementById('ellipse-center-x');
        const ellipseCenterY = document.getElementById('ellipse-center-y');
        const ellipseSemiMajor = document.getElementById('ellipse-semi-major');
        const ellipseSemiMinor = document.getElementById('ellipse-semi-minor');

        // Convert pixels to meters
        function pixelsToMeters(pixels) {
            const screenWidthMm = displayConfig.screen_width_mm || 344;
            const screenWidthPx = displayConfig.screen_width || 1920;
            const pixelPitchMm = screenWidthMm / screenWidthPx;
            return (pixels * pixelPitchMm) / 1000;  // mm to m
        }

        // Update ellipse parameters display
        function updateEllipseDisplay() {
            if (ellipseParams && currentStep === 3) {
                ellipseParamsDiv.style.display = 'block';
                ellipseCenterX.textContent = pixelsToMeters(ellipseParams.center_x).toFixed(4);
                ellipseCenterY.textContent = pixelsToMeters(ellipseParams.center_y).toFixed(4);
                ellipseSemiMajor.textContent = pixelsToMeters(ellipseParams.semi_major).toFixed(4);
                ellipseSemiMinor.textContent = pixelsToMeters(ellipseParams.semi_minor).toFixed(4);
            } else {
                ellipseParamsDiv.style.display = 'none';
            }
        }

        // Initialize canvas with screen aspect ratio
        function initCalibrationCanvas() {
            // Get screen dimensions from display config (set during loadConfig)
            screenWidth = displayConfig.screen_width || 1920;
            screenHeight = displayConfig.screen_height || 1080;

            // Set canvas size maintaining aspect ratio
            const container = document.getElementById('calibration-canvas-container');
            const containerWidth = container.clientWidth - 4;  // Account for border
            const aspectRatio = screenHeight / screenWidth;
            const canvasHeight = containerWidth * aspectRatio;

            calibrationCanvas.width = containerWidth;
            calibrationCanvas.height = canvasHeight;

            drawCalibrationCanvas();
        }

        // Draw the calibration canvas
        function drawCalibrationCanvas() {
            const ctx = calibrationCtx;
            const width = calibrationCanvas.width;
            const height = calibrationCanvas.height;

            // Clear canvas with black background
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);

            // Draw grid (same as simulator)
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            const gridParts = 4;
            for (let i = 1; i < gridParts; i++) {
                const x = (width / gridParts) * i;
                const y = (height / gridParts) * i;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // Draw connecting line between points (dim gray for B/W camera compatibility)
            if (calibrationPoints.length > 1) {
                ctx.strokeStyle = '#505050';
                ctx.lineWidth = 2;
                ctx.beginPath();
                const firstPoint = screenToCanvas(calibrationPoints[0][0], calibrationPoints[0][1]);
                ctx.moveTo(firstPoint.x, firstPoint.y);
                for (let i = 1; i < calibrationPoints.length; i++) {
                    const point = screenToCanvas(calibrationPoints[i][0], calibrationPoints[i][1]);
                    ctx.lineTo(point.x, point.y);
                }
                ctx.stroke();
            }

            // Draw ellipse fit curve if available
            if (ellipseParams && ellipseParams.coeffs && calibrationPoints.length >= 5) {
                const [A, B, C, D, E, F] = ellipseParams.coeffs;
                const centerY = ellipseParams.center_y || 0;

                // Get x range from points
                const xCoords = calibrationPoints.map(p => p[0]);
                const xMin = Math.min(...xCoords);
                const xMax = Math.max(...xCoords);

                // Determine which arc to use based on calibration points
                const pointsAbove = calibrationPoints.filter(p => p[1] < centerY).length;
                const useUpperArc = pointsAbove > calibrationPoints.length / 2;

                // Calculate ellipse points
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                let started = false;

                for (let x = xMin; x <= xMax; x += 2) {
                    // Solve quadratic: Cy² + (Bx + E)y + (Ax² + Dx + F) = 0
                    const qa = C;
                    const qb = B * x + E;
                    const qc = A * x * x + D * x + F;
                    const discriminant = qb * qb - 4 * qa * qc;

                    if (discriminant >= 0 && Math.abs(qa) > 1e-10) {
                        const sqrtDisc = Math.sqrt(discriminant);
                        const y1 = (-qb + sqrtDisc) / (2 * qa);
                        const y2 = (-qb - sqrtDisc) / (2 * qa);
                        const y = useUpperArc ? Math.min(y1, y2) : Math.max(y1, y2);

                        if (y >= 0 && y <= screenHeight) {
                            const canvasPoint = screenToCanvas(x, y);
                            if (!started) {
                                ctx.moveTo(canvasPoint.x, canvasPoint.y);
                                started = true;
                            } else {
                                ctx.lineTo(canvasPoint.x, canvasPoint.y);
                            }
                        }
                    }
                }
                ctx.stroke();
            }

            // Draw calibration points (crosshairs - grayscale for B/W camera compatibility)
            calibrationPoints.forEach((point, index) => {
                const canvasPoint = screenToCanvas(point[0], point[1]);
                const isSelected = (index === selectedPointIndex);
                const color = isSelected ? '#fff' : '#a0a0a0';  // white for selected, gray for normal
                const crossSize = isSelected ? 10 : 6;

                // Draw crosshair
                ctx.strokeStyle = color;
                ctx.lineWidth = isSelected ? 2 : 1;
                ctx.beginPath();
                ctx.moveTo(canvasPoint.x - crossSize, canvasPoint.y);
                ctx.lineTo(canvasPoint.x + crossSize, canvasPoint.y);
                ctx.moveTo(canvasPoint.x, canvasPoint.y - crossSize);
                ctx.lineTo(canvasPoint.x, canvasPoint.y + crossSize);
                ctx.stroke();

                // Draw point number
                ctx.fillStyle = color;
                ctx.font = isSelected ? 'bold 14px sans-serif' : '12px sans-serif';
                ctx.fillText((index + 1).toString(), canvasPoint.x + 8, canvasPoint.y - 6);
            });

            // Update point count
            pointCountSpan.textContent = calibrationPoints.length;
        }

        // Convert screen coordinates to canvas coordinates
        function screenToCanvas(screenX, screenY) {
            return {
                x: (screenX / screenWidth) * calibrationCanvas.width,
                y: (screenY / screenHeight) * calibrationCanvas.height
            };
        }

        // Convert canvas coordinates to screen coordinates
        function canvasToScreen(canvasX, canvasY) {
            return {
                x: Math.round((canvasX / calibrationCanvas.width) * screenWidth),
                y: Math.round((canvasY / calibrationCanvas.height) * screenHeight)
            };
        }

        // Handle mouse move on canvas (debounced)
        calibrationCanvas.addEventListener('mousemove', (e) => {
            if (currentStep !== 3) return;

            if (hoverDebounceTimer) clearTimeout(hoverDebounceTimer);

            hoverDebounceTimer = setTimeout(() => {
                const rect = calibrationCanvas.getBoundingClientRect();
                const canvasX = e.clientX - rect.left;
                const canvasY = e.clientY - rect.top;
                const screenCoords = canvasToScreen(canvasX, canvasY);

                fetch('/api/calibration/hover', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ x: screenCoords.x, y: screenCoords.y })
                });
            }, HOVER_DEBOUNCE_MS);
        });

        // Handle click on canvas
        calibrationCanvas.addEventListener('click', async (e) => {
            if (currentStep !== 3) return;

            const rect = calibrationCanvas.getBoundingClientRect();
            const canvasX = e.clientX - rect.left;
            const canvasY = e.clientY - rect.top;
            const screenCoords = canvasToScreen(canvasX, canvasY);

            try {
                const response = await fetch('/api/calibration/click', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ x: screenCoords.x, y: screenCoords.y })
                });
                const data = await response.json();

                if (data.status === 'ok' && data.points) {
                    calibrationPoints = data.points;
                    ellipseParams = data.ellipse || null;
                    // Auto-select the newly added point (points are sorted by x)
                    selectedPointIndex = data.new_index !== undefined ? data.new_index : calibrationPoints.length - 1;
                    notifySelectedIndex();
                    drawCalibrationCanvas();
                    updateEllipseDisplay();
                }
            } catch (error) {
                console.error('Failed to record calibration point:', error);
            }
        });

        // Handle reset button
        btnResetCalibration.addEventListener('click', async () => {
            try {
                const response = await fetch('/api/calibration/reset', {
                    method: 'DELETE'
                });
                const data = await response.json();

                if (data.status === 'ok') {
                    calibrationPoints = [];
                    ellipseParams = null;
                    selectedPointIndex = -1;
                    notifySelectedIndex();
                    drawCalibrationCanvas();
                    updateEllipseDisplay();
                }
            } catch (error) {
                console.error('Failed to reset calibration:', error);
            }
        });

        // Handle delete selected button
        btnDeleteSelected.addEventListener('click', async () => {
            if (calibrationPoints.length === 0 || selectedPointIndex < 0) return;

            try {
                const response = await fetch(`/api/calibration/point/${selectedPointIndex}`, {
                    method: 'DELETE'
                });
                const data = await response.json();

                if (data.status === 'ok') {
                    calibrationPoints = data.points;
                    ellipseParams = data.ellipse || null;
                    // Adjust selected index if needed
                    if (selectedPointIndex >= calibrationPoints.length) {
                        selectedPointIndex = calibrationPoints.length - 1;
                    }
                    notifySelectedIndex();
                    drawCalibrationCanvas();
                    updateEllipseDisplay();
                }
            } catch (error) {
                console.error('Failed to delete selected point:', error);
            }
        });

        // Notify server of selected index change
        async function notifySelectedIndex() {
            try {
                await fetch('/api/calibration/select', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ index: selectedPointIndex })
                });
            } catch (error) {
                console.error('Failed to update selected index:', error);
            }
        }

        // Move selected point by dx, dy
        async function moveSelectedPoint(dx, dy) {
            if (selectedPointIndex < 0 || selectedPointIndex >= calibrationPoints.length) return;

            try {
                const response = await fetch(`/api/calibration/point/${selectedPointIndex}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ dx, dy })
                });
                const data = await response.json();

                if (data.status === 'ok' && data.points) {
                    calibrationPoints = data.points;
                    ellipseParams = data.ellipse || null;
                    drawCalibrationCanvas();
                    updateEllipseDisplay();
                }
            } catch (error) {
                console.error('Failed to move point:', error);
            }
        }

        // Select previous point (with wrap around)
        function selectPreviousPoint() {
            if (calibrationPoints.length === 0) return;
            if (selectedPointIndex <= 0) {
                selectedPointIndex = calibrationPoints.length - 1;
            } else {
                selectedPointIndex--;
            }
            notifySelectedIndex();
            drawCalibrationCanvas();
        }

        // Select next point (with wrap around)
        function selectNextPoint() {
            if (calibrationPoints.length === 0) return;
            if (selectedPointIndex < 0 || selectedPointIndex >= calibrationPoints.length - 1) {
                selectedPointIndex = 0;
            } else {
                selectedPointIndex++;
            }
            notifySelectedIndex();
            drawCalibrationCanvas();
        }

        // Keyboard handler for point manipulation
        document.addEventListener('keydown', (e) => {
            // Only handle keys when on calibration step
            if (currentStep !== 3) return;

            // Don't handle if focus is on an input element
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            let handled = false;

            switch (e.key) {
                // Movement keys: s=left, f=right, e=up, d=down (and arrow keys)
                case 's':
                case 'ArrowLeft':
                    moveSelectedPoint(-1, 0);
                    handled = true;
                    break;
                case 'f':
                case 'ArrowRight':
                    moveSelectedPoint(1, 0);
                    handled = true;
                    break;
                case 'e':
                case 'ArrowUp':
                    moveSelectedPoint(0, -1);
                    handled = true;
                    break;
                case 'd':
                case 'ArrowDown':
                    moveSelectedPoint(0, 1);
                    handled = true;
                    break;

                // Selection keys: q/PageUp=previous, a/PageDown=next
                case 'q':
                case 'PageUp':
                    selectPreviousPoint();
                    handled = true;
                    break;
                case 'a':
                case 'PageDown':
                    selectNextPoint();
                    handled = true;
                    break;
            }

            if (handled) {
                e.preventDefault();
            }
        });

        // Load existing calibration points
        async function loadCalibrationPoints() {
            try {
                const response = await fetch('/api/calibration/points');
                const data = await response.json();
                calibrationPoints = data.points || [];
                ellipseParams = data.ellipse || null;
                initCalibrationCanvas();
                updateEllipseDisplay();
            } catch (error) {
                console.error('Failed to load calibration points:', error);
                initCalibrationCanvas();
            }
        }

        // Initialize
        loadConfig();

        // ===== Simulation Control =====
        const btnPlayPause = document.getElementById('btn-play-pause');
        const btnStopSim = document.getElementById('btn-stop-sim');
        const btnResetSim = document.getElementById('btn-reset-sim');
        const btnSkipBack = document.getElementById('btn-skip-back');
        const btnSkipForward = document.getElementById('btn-skip-forward');
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');
        const countdownTime = document.getElementById('countdown-time');
        const progressFill = document.getElementById('progress-fill');
        const progressPercent = document.getElementById('progress-percent');
        const elapsedTime = document.getElementById('elapsed-time');
        const totalTime = document.getElementById('total-time');
        const progressBar = document.getElementById('progress-bar');

        let simulationSetup = false;
        let simulationTotalSeconds = 0;
        let simulationPollingInterval = null;
        let isPlaying = false;

        // Format seconds as M:SS or MM:SS
        function formatTime(seconds) {
            if (seconds === undefined || seconds === null || isNaN(seconds)) {
                return '--:--';
            }
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Update simulation UI from status
        function updateSimulationUI(status) {
            // Update progress bar
            const progress = status.progress || 0;
            progressFill.style.width = `${progress}%`;
            progressPercent.textContent = `${progress.toFixed(1)}%`;

            // Update times
            elapsedTime.textContent = formatTime(status.elapsed_seconds);
            countdownTime.textContent = formatTime(status.remaining_seconds);

            if (status.total_seconds !== undefined) {
                totalTime.textContent = formatTime(status.total_seconds);
                simulationTotalSeconds = status.total_seconds;
            }

            // Update play/pause button state
            isPlaying = status.running;
            if (status.running) {
                btnPlayPause.textContent = '⏸';
                btnPlayPause.classList.add('playing');
            } else {
                btnPlayPause.textContent = '▶';
                btnPlayPause.classList.remove('playing');
            }

            // Update status indicator
            statusDot.className = 'status-dot';
            if (status.complete) {
                statusDot.classList.add('complete');
                statusText.textContent = 'Complete';
                btnPlayPause.disabled = true;
                btnSkipForward.disabled = true;
            } else if (status.running) {
                statusDot.classList.add('running');
                statusText.textContent = 'Running';
                btnPlayPause.disabled = false;
                btnSkipForward.disabled = false;
            } else if (status.elapsed_seconds > 0) {
                statusDot.classList.add('paused');
                statusText.textContent = 'Paused';
                btnPlayPause.disabled = false;
                btnSkipForward.disabled = false;
            } else {
                statusDot.classList.add('ready');
                statusText.textContent = 'Ready';
                btnPlayPause.disabled = false;
                btnSkipForward.disabled = false;
            }

            // Disable skip back if at start
            btnSkipBack.disabled = (status.elapsed_seconds || 0) <= 0;

            // Update current velocity display
            if (status.current_velocity !== undefined) {
                simCurrentVelocitySpan.textContent = status.current_velocity.toFixed(4);
            }
        }

        // Poll simulation status
        async function pollSimulationStatus() {
            if (currentStep !== 5) return;

            try {
                const response = await fetch('/api/simulation/status');
                const status = await response.json();
                updateSimulationUI(status);

                // Stop polling if complete
                if (status.complete && simulationPollingInterval) {
                    clearInterval(simulationPollingInterval);
                    simulationPollingInterval = null;
                }
            } catch (error) {
                console.error('Failed to poll simulation status:', error);
            }
        }

        // Velocity source display elements
        const simCurrentVelocitySpan = document.getElementById('sim-current-velocity');
        const velocitySourceLabel = document.getElementById('velocity-source-label');

        // Setup simulation when entering step 5
        async function setupSimulation() {
            try {
                const response = await fetch('/api/simulation/setup', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });
                const data = await response.json();

                if (data.status === 'ok') {
                    simulationSetup = true;
                    simulationTotalSeconds = data.total_seconds;
                    totalTime.textContent = formatTime(data.total_seconds);
                    countdownTime.textContent = formatTime(data.total_seconds);
                    btnPlayPause.disabled = false;

                    // Display velocity source
                    simCurrentVelocitySpan.textContent = data.pixels_per_second.toFixed(4);
                    if (data.velocity_source === 'measured_interpolated') {
                        velocitySourceLabel.textContent = 'interpolated';
                        velocitySourceLabel.style.color = '#4caf50';  // Green for measured
                    } else {
                        velocitySourceLabel.textContent = 'estimated';
                        velocitySourceLabel.style.color = '#aaa';  // Gray for calculated
                    }
                } else {
                    console.error('Simulation setup failed:', data.error);
                    statusText.textContent = 'Setup Error';
                    btnPlayPause.disabled = true;
                }
            } catch (error) {
                console.error('Failed to setup simulation:', error);
                statusText.textContent = 'Setup Error';
                btnPlayPause.disabled = true;
            }
        }

        // Play/Pause toggle
        btnPlayPause.addEventListener('click', async () => {
            try {
                if (isPlaying) {
                    // Pause
                    await fetch('/api/simulation/stop', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({})
                    });
                } else {
                    // Play
                    await fetch('/api/simulation/start', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({})
                    });
                    // Start polling for status updates
                    if (!simulationPollingInterval) {
                        simulationPollingInterval = setInterval(pollSimulationStatus, 500);
                    }
                }
                pollSimulationStatus();
            } catch (error) {
                console.error('Failed to toggle play/pause:', error);
            }
        });

        // Stop simulation (pause and reset)
        btnStopSim.addEventListener('click', async () => {
            try {
                await fetch('/api/simulation/stop', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });
                await fetch('/api/simulation/reset', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });
                await setupSimulation();
                pollSimulationStatus();
            } catch (error) {
                console.error('Failed to stop simulation:', error);
            }
        });

        // Reset to start
        btnResetSim.addEventListener('click', async () => {
            try {
                await fetch('/api/simulation/reset', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });
                await setupSimulation();
                pollSimulationStatus();
            } catch (error) {
                console.error('Failed to reset simulation:', error);
            }
        });

        // Skip back 10 seconds
        btnSkipBack.addEventListener('click', async () => {
            try {
                await fetch('/api/simulation/skip', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ seconds: -10 })
                });
                pollSimulationStatus();
            } catch (error) {
                console.error('Failed to skip back:', error);
            }
        });

        // Skip forward 10 seconds
        btnSkipForward.addEventListener('click', async () => {
            try {
                await fetch('/api/simulation/skip', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ seconds: 10 })
                });
                pollSimulationStatus();
            } catch (error) {
                console.error('Failed to skip forward:', error);
            }
        });

        // Click on progress bar to seek
        progressBar.addEventListener('click', async (e) => {
            if (simulationTotalSeconds <= 0) return;

            const rect = progressBar.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const percentage = clickX / rect.width;
            const elapsedSeconds = percentage * simulationTotalSeconds;

            try {
                await fetch('/api/simulation/seek', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ elapsed_seconds: elapsedSeconds })
                });
                pollSimulationStatus();
            } catch (error) {
                console.error('Failed to seek:', error);
            }
        });

        // Hook into step navigation to setup simulation when entering step 4
        const originalStepClickHandlers = [];

        // Modify btnNext click handler to setup simulation when entering step 5
        const originalBtnNextHandler = btnNext.onclick;
        btnNext.addEventListener('click', async () => {
            // Wait a bit for the step to change
            setTimeout(async () => {
                if (currentStep === 5) {
                    await setupSimulation();
                    pollSimulationStatus();
                    // Start continuous polling
                    if (!simulationPollingInterval) {
                        simulationPollingInterval = setInterval(pollSimulationStatus, 500);
                    }
                } else if (simulationPollingInterval) {
                    clearInterval(simulationPollingInterval);
                    simulationPollingInterval = null;
                }
            }, 100);
        });

        // Also handle direct tab clicks
        for (let stepNum = 1; stepNum <= 5; stepNum++) {
            const stepElement = document.getElementById(`step-${stepNum}`);
            stepElement.addEventListener('click', async () => {
                setTimeout(async () => {
                    if (currentStep === 5) {
                        await setupSimulation();
                        pollSimulationStatus();
                        if (!simulationPollingInterval) {
                            simulationPollingInterval = setInterval(pollSimulationStatus, 500);
                        }
                    } else if (simulationPollingInterval) {
                        clearInterval(simulationPollingInterval);
                        simulationPollingInterval = null;
                    }
                }, 100);
            });
        }

        // Handle btnBack to stop polling when leaving step 5
        btnBack.addEventListener('click', () => {
            setTimeout(() => {
                if (currentStep !== 5 && simulationPollingInterval) {
                    clearInterval(simulationPollingInterval);
                    simulationPollingInterval = null;
                }
            }, 100);
        });

        // ===== Velocity Measurement =====
        let velocityStripeWidth = 0;
        let velocityPixelsPerSecond = 0;
        let selectedStripe = 'left';
        let stopwatchRunning = false;
        let stopwatchStartTime = 0;
        let stopwatchAnimationFrame = null;
        let velocityMeasurements = {
            left: null,
            middle: null,
            right: null
        };

        const stopwatchTimeDisplay = document.getElementById('stopwatch-time');
        const btnStopwatchToggle = document.getElementById('btn-stopwatch-toggle');
        const btnStopwatchReset = document.getElementById('btn-stopwatch-reset');
        const stripeButtons = document.querySelectorAll('.stripe-btn');
        const expectedCrossingSpan = document.getElementById('expected-crossing');
        const stripeWidthSpan = document.getElementById('stripe-width');
        const maxVelocityText = document.getElementById('max-velocity-text');
        const maxVelocitySpan = document.getElementById('max-velocity');

        // Format time as MM:SS.mmm
        function formatStopwatchTime(ms) {
            const totalSeconds = ms / 1000;
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = Math.floor(totalSeconds % 60);
            const millis = Math.floor(ms % 1000);
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${millis.toString().padStart(3, '0')}`;
        }

        // Update stopwatch display
        function updateStopwatchDisplay() {
            if (stopwatchRunning) {
                const elapsed = performance.now() - stopwatchStartTime;
                stopwatchTimeDisplay.textContent = formatStopwatchTime(elapsed);
                stopwatchAnimationFrame = requestAnimationFrame(updateStopwatchDisplay);
            }
        }

        // Start/Stop toggle
        btnStopwatchToggle.addEventListener('click', async () => {
            if (stopwatchRunning) {
                // Stop
                const elapsed = performance.now() - stopwatchStartTime;
                const elapsedSeconds = elapsed / 1000;
                stopwatchRunning = false;
                if (stopwatchAnimationFrame) {
                    cancelAnimationFrame(stopwatchAnimationFrame);
                }
                btnStopwatchToggle.textContent = 'Start';
                btnStopwatchToggle.classList.remove('btn-stop');
                btnStopwatchToggle.classList.add('btn-start');

                // Record the measurement
                try {
                    await fetch('/api/velocity/time', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            stripe: selectedStripe,
                            time_seconds: elapsedSeconds
                        })
                    });
                    velocityMeasurements[selectedStripe] = elapsedSeconds;
                    updateMeasurementDisplay();
                    selectNextUnrecordedStripe();
                } catch (error) {
                    console.error('Failed to record velocity time:', error);
                }
            } else {
                // Start
                stopwatchStartTime = performance.now();
                stopwatchRunning = true;
                btnStopwatchToggle.textContent = 'Stop';
                btnStopwatchToggle.classList.remove('btn-start');
                btnStopwatchToggle.classList.add('btn-stop');
                updateStopwatchDisplay();
            }
        });

        // Reset stopwatch
        btnStopwatchReset.addEventListener('click', () => {
            if (stopwatchRunning) {
                stopwatchRunning = false;
                if (stopwatchAnimationFrame) {
                    cancelAnimationFrame(stopwatchAnimationFrame);
                }
                btnStopwatchToggle.textContent = 'Start';
                btnStopwatchToggle.classList.remove('btn-stop');
                btnStopwatchToggle.classList.add('btn-start');
            }
            stopwatchTimeDisplay.textContent = '00:00.000';
        });

        // Stripe selection
        stripeButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                stripeButtons.forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                selectedStripe = btn.dataset.stripe;
                // Reset stopwatch when changing stripe
                btnStopwatchReset.click();
            });
        });

        // Select next unrecorded stripe
        function selectNextUnrecordedStripe() {
            const stripes = ['left', 'middle', 'right'];
            for (const stripe of stripes) {
                if (velocityMeasurements[stripe] === null) {
                    stripeButtons.forEach(btn => btn.classList.remove('selected'));
                    document.getElementById(`stripe-${stripe}`).classList.add('selected');
                    selectedStripe = stripe;
                    btnStopwatchReset.click();
                    return;
                }
            }
        }

        // Update measurement display
        function updateMeasurementDisplay() {
            ['left', 'middle', 'right'].forEach(stripe => {
                const card = document.getElementById(`measurement-${stripe}`);
                const valueEl = document.getElementById(`value-${stripe}`);
                const velocityEl = document.getElementById(`velocity-${stripe}`);
                const clearBtn = document.getElementById(`clear-${stripe}`);
                const stripeBtn = document.getElementById(`stripe-${stripe}`);

                if (velocityMeasurements[stripe] !== null) {
                    valueEl.textContent = formatStopwatchTime(velocityMeasurements[stripe] * 1000);
                    // Calculate and display velocity for this stripe
                    if (velocityStripeWidth > 0 && velocityMeasurements[stripe] > 0) {
                        const stripeVelocity = velocityStripeWidth / velocityMeasurements[stripe];
                        velocityEl.textContent = stripeVelocity.toFixed(3) + ' px/s';
                    } else {
                        velocityEl.textContent = '-- px/s';
                    }
                    card.classList.add('has-value');
                    clearBtn.disabled = false;
                    stripeBtn.classList.add('recorded');
                } else {
                    valueEl.textContent = '--:--';
                    velocityEl.textContent = '-- px/s';
                    card.classList.remove('has-value');
                    clearBtn.disabled = true;
                    stripeBtn.classList.remove('recorded');
                }
            });

            // Calculate max velocity if all measurements are complete
            // Max velocity = min time (velocity = distance/time)
            const validMeasurements = Object.values(velocityMeasurements).filter(v => v !== null);
            if (validMeasurements.length > 0 && velocityStripeWidth > 0) {
                const minTime = Math.min(...validMeasurements);
                const measuredVelocity = velocityStripeWidth / minTime;
                maxVelocitySpan.textContent = measuredVelocity.toFixed(3);
                maxVelocityText.style.display = 'block';
            } else {
                maxVelocityText.style.display = 'none';
            }
        }

        // Clear handlers
        ['left', 'middle', 'right'].forEach(stripe => {
            document.getElementById(`clear-${stripe}`).addEventListener('click', async () => {
                try {
                    await fetch(`/api/velocity/time/${stripe}`, { method: 'DELETE' });
                    velocityMeasurements[stripe] = null;
                    updateMeasurementDisplay();
                } catch (error) {
                    console.error('Failed to clear velocity time:', error);
                }
            });
        });

        // Setup velocity measurement when entering step 4
        async function setupVelocityMeasurement() {
            try {
                // First setup the display
                const setupResponse = await fetch('/api/velocity/setup', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });
                const setupData = await setupResponse.json();

                if (setupData.status === 'ok') {
                    velocityStripeWidth = setupData.stripe_width_pixels;
                    velocityPixelsPerSecond = setupData.pixels_per_second;
                    expectedCrossingSpan.textContent = setupData.expected_crossing_seconds;
                    stripeWidthSpan.textContent = velocityStripeWidth;
                }

                // Load existing measurements
                const velocityResponse = await fetch('/api/velocity');
                const velocityData = await velocityResponse.json();

                velocityMeasurements.left = velocityData.left_time_seconds;
                velocityMeasurements.middle = velocityData.middle_time_seconds;
                velocityMeasurements.right = velocityData.right_time_seconds;
                updateMeasurementDisplay();

                // Select first unrecorded stripe
                selectNextUnrecordedStripe();

            } catch (error) {
                console.error('Failed to setup velocity measurement:', error);
            }
        }
    </script>
</body>
</html>
